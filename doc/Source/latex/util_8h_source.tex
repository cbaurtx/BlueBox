\doxysection{util.\+h}
\hypertarget{util_8h_source}{}\label{util_8h_source}\index{managed\_components/espressif\_\_nghttp/nghttp2/src/util.h@{managed\_components/espressif\_\_nghttp/nghttp2/src/util.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ \textcolor{comment}{/*}}
\DoxyCodeLine{00002\ \textcolor{comment}{\ *\ nghttp2\ -\/\ HTTP/2\ C\ Library}}
\DoxyCodeLine{00003\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00004\ \textcolor{comment}{\ *\ Copyright\ (c)\ 2012\ Tatsuhiro\ Tsujikawa}}
\DoxyCodeLine{00005\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00006\ \textcolor{comment}{\ *\ Permission\ is\ hereby\ granted,\ free\ of\ charge,\ to\ any\ person\ obtaining}}
\DoxyCodeLine{00007\ \textcolor{comment}{\ *\ a\ copy\ of\ this\ software\ and\ associated\ documentation\ files\ (the}}
\DoxyCodeLine{00008\ \textcolor{comment}{\ *\ "{}Software"{}),\ to\ deal\ in\ the\ Software\ without\ restriction,\ including}}
\DoxyCodeLine{00009\ \textcolor{comment}{\ *\ without\ limitation\ the\ rights\ to\ use,\ copy,\ modify,\ merge,\ publish,}}
\DoxyCodeLine{00010\ \textcolor{comment}{\ *\ distribute,\ sublicense,\ and/or\ sell\ copies\ of\ the\ Software,\ and\ to}}
\DoxyCodeLine{00011\ \textcolor{comment}{\ *\ permit\ persons\ to\ whom\ the\ Software\ is\ furnished\ to\ do\ so,\ subject\ to}}
\DoxyCodeLine{00012\ \textcolor{comment}{\ *\ the\ following\ conditions:}}
\DoxyCodeLine{00013\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00014\ \textcolor{comment}{\ *\ The\ above\ copyright\ notice\ and\ this\ permission\ notice\ shall\ be}}
\DoxyCodeLine{00015\ \textcolor{comment}{\ *\ included\ in\ all\ copies\ or\ substantial\ portions\ of\ the\ Software.}}
\DoxyCodeLine{00016\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00017\ \textcolor{comment}{\ *\ THE\ SOFTWARE\ IS\ PROVIDED\ "{}AS\ IS"{},\ WITHOUT\ WARRANTY\ OF\ ANY\ KIND,}}
\DoxyCodeLine{00018\ \textcolor{comment}{\ *\ EXPRESS\ OR\ IMPLIED,\ INCLUDING\ BUT\ NOT\ LIMITED\ TO\ THE\ WARRANTIES\ OF}}
\DoxyCodeLine{00019\ \textcolor{comment}{\ *\ MERCHANTABILITY,\ FITNESS\ FOR\ A\ PARTICULAR\ PURPOSE\ AND}}
\DoxyCodeLine{00020\ \textcolor{comment}{\ *\ NONINFRINGEMENT.\ IN\ NO\ EVENT\ SHALL\ THE\ AUTHORS\ OR\ COPYRIGHT\ HOLDERS\ BE}}
\DoxyCodeLine{00021\ \textcolor{comment}{\ *\ LIABLE\ FOR\ ANY\ CLAIM,\ DAMAGES\ OR\ OTHER\ LIABILITY,\ WHETHER\ IN\ AN\ ACTION}}
\DoxyCodeLine{00022\ \textcolor{comment}{\ *\ OF\ CONTRACT,\ TORT\ OR\ OTHERWISE,\ ARISING\ FROM,\ OUT\ OF\ OR\ IN\ CONNECTION}}
\DoxyCodeLine{00023\ \textcolor{comment}{\ *\ WITH\ THE\ SOFTWARE\ OR\ THE\ USE\ OR\ OTHER\ DEALINGS\ IN\ THE\ SOFTWARE.}}
\DoxyCodeLine{00024\ \textcolor{comment}{\ */}}
\DoxyCodeLine{00025\ \textcolor{preprocessor}{\#ifndef\ UTIL\_H}}
\DoxyCodeLine{00026\ \textcolor{preprocessor}{\#define\ UTIL\_H}}
\DoxyCodeLine{00027\ }
\DoxyCodeLine{00028\ \textcolor{preprocessor}{\#include\ "{}nghttp2\_config.h"{}}}
\DoxyCodeLine{00029\ }
\DoxyCodeLine{00030\ \textcolor{preprocessor}{\#ifdef\ HAVE\_UNISTD\_H}}
\DoxyCodeLine{00031\ \textcolor{preprocessor}{\#\ \ include\ <unistd.h>}}
\DoxyCodeLine{00032\ \textcolor{preprocessor}{\#endif\ }\textcolor{comment}{//\ HAVE\_UNISTD\_H}}
\DoxyCodeLine{00033\ \textcolor{preprocessor}{\#include\ <getopt.h>}}
\DoxyCodeLine{00034\ \textcolor{preprocessor}{\#ifdef\ HAVE\_NETDB\_H}}
\DoxyCodeLine{00035\ \textcolor{preprocessor}{\#\ \ include\ <netdb.h>}}
\DoxyCodeLine{00036\ \textcolor{preprocessor}{\#endif\ }\textcolor{comment}{//\ HAVE\_NETDB\_H}}
\DoxyCodeLine{00037\ \textcolor{preprocessor}{\#ifdef\ \_\_QNX\_\_}}
\DoxyCodeLine{00038\ \textcolor{preprocessor}{\#\ \ include\ <sys/time.h>}}
\DoxyCodeLine{00039\ \textcolor{preprocessor}{\#endif\ }\textcolor{comment}{//\ \_\_QNX\_\_}}
\DoxyCodeLine{00040\ }
\DoxyCodeLine{00041\ \textcolor{preprocessor}{\#include\ <cmath>}}
\DoxyCodeLine{00042\ \textcolor{preprocessor}{\#include\ <cstring>}}
\DoxyCodeLine{00043\ \textcolor{preprocessor}{\#include\ <cassert>}}
\DoxyCodeLine{00044\ \textcolor{preprocessor}{\#include\ <vector>}}
\DoxyCodeLine{00045\ \textcolor{preprocessor}{\#include\ <string>}}
\DoxyCodeLine{00046\ \textcolor{preprocessor}{\#include\ <algorithm>}}
\DoxyCodeLine{00047\ \textcolor{preprocessor}{\#include\ <sstream>}}
\DoxyCodeLine{00048\ \textcolor{preprocessor}{\#include\ <memory>}}
\DoxyCodeLine{00049\ \textcolor{preprocessor}{\#include\ <chrono>}}
\DoxyCodeLine{00050\ \textcolor{preprocessor}{\#include\ <map>}}
\DoxyCodeLine{00051\ \textcolor{preprocessor}{\#include\ <random>}}
\DoxyCodeLine{00052\ \textcolor{preprocessor}{\#include\ <optional>}}
\DoxyCodeLine{00053\ }
\DoxyCodeLine{00054\ \textcolor{preprocessor}{\#ifdef\ HAVE\_LIBEV}}
\DoxyCodeLine{00055\ \textcolor{preprocessor}{\#\ \ include\ <ev.h>}}
\DoxyCodeLine{00056\ \textcolor{preprocessor}{\#endif\ }\textcolor{comment}{//\ HAVE\_LIBEV}}
\DoxyCodeLine{00057\ }
\DoxyCodeLine{00058\ \textcolor{preprocessor}{\#include\ "{}urlparse.h"{}}}
\DoxyCodeLine{00059\ }
\DoxyCodeLine{00060\ \textcolor{preprocessor}{\#include\ "{}template.h"{}}}
\DoxyCodeLine{00061\ \textcolor{preprocessor}{\#include\ "{}network.h"{}}}
\DoxyCodeLine{00062\ \textcolor{preprocessor}{\#include\ "{}allocator.h"{}}}
\DoxyCodeLine{00063\ }
\DoxyCodeLine{00064\ \textcolor{keyword}{namespace\ }nghttp2\ \{}
\DoxyCodeLine{00065\ }
\DoxyCodeLine{00066\ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{auto}\ NGHTTP2\_H2\_ALPN\ =\ \textcolor{stringliteral}{"{}\(\backslash\)x2h2"{}}\_sr;}
\DoxyCodeLine{00067\ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{auto}\ NGHTTP2\_H2\ =\ \textcolor{stringliteral}{"{}h2"{}}\_sr;}
\DoxyCodeLine{00068\ }
\DoxyCodeLine{00069\ \textcolor{comment}{//\ The\ additional\ HTTP/2\ protocol\ ALPN\ protocol\ identifier\ we\ also}}
\DoxyCodeLine{00070\ \textcolor{comment}{//\ supports\ for\ our\ applications\ to\ make\ smooth\ migration\ into\ final}}
\DoxyCodeLine{00071\ \textcolor{comment}{//\ h2\ ALPN\ ID.}}
\DoxyCodeLine{00072\ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{auto}\ NGHTTP2\_H2\_16\_ALPN\ =\ \textcolor{stringliteral}{"{}\(\backslash\)x5h2-\/16"{}}\_sr;}
\DoxyCodeLine{00073\ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{auto}\ NGHTTP2\_H2\_16\ =\ \textcolor{stringliteral}{"{}h2-\/16"{}}\_sr;}
\DoxyCodeLine{00074\ }
\DoxyCodeLine{00075\ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{auto}\ NGHTTP2\_H2\_14\_ALPN\ =\ \textcolor{stringliteral}{"{}\(\backslash\)x5h2-\/14"{}}\_sr;}
\DoxyCodeLine{00076\ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{auto}\ NGHTTP2\_H2\_14\ =\ \textcolor{stringliteral}{"{}h2-\/14"{}}\_sr;}
\DoxyCodeLine{00077\ }
\DoxyCodeLine{00078\ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{auto}\ NGHTTP2\_H1\_1\_ALPN\ =\ \textcolor{stringliteral}{"{}\(\backslash\)x8http/1.1"{}}\_sr;}
\DoxyCodeLine{00079\ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{auto}\ NGHTTP2\_H1\_1\ =\ \textcolor{stringliteral}{"{}http/1.1"{}}\_sr;}
\DoxyCodeLine{00080\ }
\DoxyCodeLine{00081\ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{size\_t}\ NGHTTP2\_MAX\_UINT64\_DIGITS\ =\ str\_size(\textcolor{stringliteral}{"{}18446744073709551615"{}});}
\DoxyCodeLine{00082\ }
\DoxyCodeLine{00083\ \textcolor{keyword}{namespace\ }util\ \{}
\DoxyCodeLine{00084\ }
\DoxyCodeLine{00085\ \textcolor{keyword}{extern}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ UPPER\_XDIGITS[];}
\DoxyCodeLine{00086\ }
\DoxyCodeLine{00087\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ is\_alpha(\textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ c)\ \{}
\DoxyCodeLine{00088\ \ \ \textcolor{keywordflow}{return}\ (\textcolor{charliteral}{'A'}\ <=\ c\ \&\&\ c\ <=\ \textcolor{charliteral}{'Z'})\ ||\ (\textcolor{charliteral}{'a'}\ <=\ c\ \&\&\ c\ <=\ \textcolor{charliteral}{'z'});}
\DoxyCodeLine{00089\ \}}
\DoxyCodeLine{00090\ }
\DoxyCodeLine{00091\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ is\_digit(\textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ c)\ \{\ \textcolor{keywordflow}{return}\ \textcolor{charliteral}{'0'}\ <=\ c\ \&\&\ c\ <=\ \textcolor{charliteral}{'9'};\ \}}
\DoxyCodeLine{00092\ }
\DoxyCodeLine{00093\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ is\_hex\_digit(\textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ c)\ \{}
\DoxyCodeLine{00094\ \ \ \textcolor{keywordflow}{return}\ is\_digit(c)\ ||\ (\textcolor{charliteral}{'A'}\ <=\ c\ \&\&\ c\ <=\ \textcolor{charliteral}{'F'})\ ||\ (\textcolor{charliteral}{'a'}\ <=\ c\ \&\&\ c\ <=\ \textcolor{charliteral}{'f'});}
\DoxyCodeLine{00095\ \}}
\DoxyCodeLine{00096\ }
\DoxyCodeLine{00097\ \textcolor{comment}{//\ Returns\ true\ if\ |s|\ is\ hex\ string.}}
\DoxyCodeLine{00098\ \textcolor{keywordtype}{bool}\ is\_hex\_string(\textcolor{keyword}{const}\ StringRef\ \&s);}
\DoxyCodeLine{00099\ }
\DoxyCodeLine{00100\ \textcolor{keywordtype}{bool}\ in\_rfc3986\_unreserved\_chars(\textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ c);}
\DoxyCodeLine{00101\ }
\DoxyCodeLine{00102\ \textcolor{keywordtype}{bool}\ in\_rfc3986\_sub\_delims(\textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ c);}
\DoxyCodeLine{00103\ }
\DoxyCodeLine{00104\ \textcolor{comment}{//\ Returns\ true\ if\ |c|\ is\ in\ token\ (HTTP-\/p1,\ Section\ 3.2.6)}}
\DoxyCodeLine{00105\ \textcolor{keywordtype}{bool}\ in\_token(\textcolor{keywordtype}{char}\ c);}
\DoxyCodeLine{00106\ }
\DoxyCodeLine{00107\ \textcolor{keywordtype}{bool}\ in\_attr\_char(\textcolor{keywordtype}{char}\ c);}
\DoxyCodeLine{00108\ }
\DoxyCodeLine{00109\ \textcolor{comment}{//\ Returns\ integer\ corresponding\ to\ hex\ notation\ |c|.\ \ If}}
\DoxyCodeLine{00110\ \textcolor{comment}{//\ is\_hex\_digit(c)\ is\ false,\ it\ returns\ 256.}}
\DoxyCodeLine{00111\ uint32\_t\ hex\_to\_uint(\textcolor{keywordtype}{char}\ c);}
\DoxyCodeLine{00112\ }
\DoxyCodeLine{00113\ std::string\ percent\_encode(\textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}\ *target,\ \textcolor{keywordtype}{size\_t}\ len);}
\DoxyCodeLine{00114\ }
\DoxyCodeLine{00115\ std::string\ percent\_encode(\textcolor{keyword}{const}\ std::string\ \&target);}
\DoxyCodeLine{00116\ }
\DoxyCodeLine{00117\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InputIt>}
\DoxyCodeLine{00118\ std::string\ percent\_decode(InputIt\ first,\ InputIt\ last)\ \{}
\DoxyCodeLine{00119\ \ \ std::string\ result;}
\DoxyCodeLine{00120\ \ \ result.resize(last\ -\/\ first);}
\DoxyCodeLine{00121\ \ \ \textcolor{keyword}{auto}\ p\ =\ std::begin(result);}
\DoxyCodeLine{00122\ \ \ \textcolor{keywordflow}{for}\ (;\ first\ !=\ last;\ ++first)\ \{}
\DoxyCodeLine{00123\ \ \ \ \ \textcolor{keywordflow}{if}\ (*first\ !=\ \textcolor{charliteral}{'\%'})\ \{}
\DoxyCodeLine{00124\ \ \ \ \ \ \ *p++\ =\ *first;}
\DoxyCodeLine{00125\ \ \ \ \ \ \ \textcolor{keywordflow}{continue};}
\DoxyCodeLine{00126\ \ \ \ \ \}}
\DoxyCodeLine{00127\ }
\DoxyCodeLine{00128\ \ \ \ \ \textcolor{keywordflow}{if}\ (first\ +\ 1\ !=\ last\ \&\&\ first\ +\ 2\ !=\ last\ \&\&\ is\_hex\_digit(*(first\ +\ 1))\ \&\&}
\DoxyCodeLine{00129\ \ \ \ \ \ \ \ \ is\_hex\_digit(*(first\ +\ 2)))\ \{}
\DoxyCodeLine{00130\ \ \ \ \ \ \ *p++\ =\ (hex\_to\_uint(*(first\ +\ 1))\ <<\ 4)\ +\ hex\_to\_uint(*(first\ +\ 2));}
\DoxyCodeLine{00131\ \ \ \ \ \ \ first\ +=\ 2;}
\DoxyCodeLine{00132\ \ \ \ \ \ \ \textcolor{keywordflow}{continue};}
\DoxyCodeLine{00133\ \ \ \ \ \}}
\DoxyCodeLine{00134\ }
\DoxyCodeLine{00135\ \ \ \ \ *p++\ =\ *first;}
\DoxyCodeLine{00136\ \ \ \}}
\DoxyCodeLine{00137\ \ \ result.resize(p\ -\/\ std::begin(result));}
\DoxyCodeLine{00138\ \ \ \textcolor{keywordflow}{return}\ result;}
\DoxyCodeLine{00139\ \}}
\DoxyCodeLine{00140\ }
\DoxyCodeLine{00141\ StringRef\ percent\_decode(BlockAllocator\ \&balloc,\ \textcolor{keyword}{const}\ StringRef\ \&src);}
\DoxyCodeLine{00142\ }
\DoxyCodeLine{00143\ \textcolor{comment}{//\ Percent\ encode\ |target|\ if\ character\ is\ not\ in\ token\ or\ '\%'.}}
\DoxyCodeLine{00144\ StringRef\ percent\_encode\_token(BlockAllocator\ \&balloc,\ \textcolor{keyword}{const}\ StringRef\ \&target);}
\DoxyCodeLine{00145\ }
\DoxyCodeLine{00146\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ OutputIt>}
\DoxyCodeLine{00147\ OutputIt\ percent\_encode\_token(OutputIt\ it,\ \textcolor{keyword}{const}\ StringRef\ \&target)\ \{}
\DoxyCodeLine{00148\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ first\ =\ std::begin(target);\ first\ !=\ std::end(target);\ ++first)\ \{}
\DoxyCodeLine{00149\ \ \ \ \ uint8\_t\ c\ =\ *first;}
\DoxyCodeLine{00150\ }
\DoxyCodeLine{00151\ \ \ \ \ \textcolor{keywordflow}{if}\ (c\ !=\ \textcolor{charliteral}{'\%'}\ \&\&\ in\_token(c))\ \{}
\DoxyCodeLine{00152\ \ \ \ \ \ \ *it++\ =\ c;}
\DoxyCodeLine{00153\ \ \ \ \ \ \ \textcolor{keywordflow}{continue};}
\DoxyCodeLine{00154\ \ \ \ \ \}}
\DoxyCodeLine{00155\ }
\DoxyCodeLine{00156\ \ \ \ \ *it++\ =\ \textcolor{charliteral}{'\%'};}
\DoxyCodeLine{00157\ \ \ \ \ *it++\ =\ UPPER\_XDIGITS[c\ >>\ 4];}
\DoxyCodeLine{00158\ \ \ \ \ *it++\ =\ UPPER\_XDIGITS[(c\ \&\ 0x0f)];}
\DoxyCodeLine{00159\ \ \ \}}
\DoxyCodeLine{00160\ }
\DoxyCodeLine{00161\ \ \ \textcolor{keywordflow}{return}\ it;}
\DoxyCodeLine{00162\ \}}
\DoxyCodeLine{00163\ }
\DoxyCodeLine{00164\ \textcolor{comment}{//\ Returns\ the\ number\ of\ bytes\ written\ by\ percent\_encode\_token\ with}}
\DoxyCodeLine{00165\ \textcolor{comment}{//\ the\ same\ |target|\ parameter.\ \ The\ return\ value\ does\ not\ include\ a}}
\DoxyCodeLine{00166\ \textcolor{comment}{//\ terminal\ NUL\ byte.}}
\DoxyCodeLine{00167\ \textcolor{keywordtype}{size\_t}\ percent\_encode\_tokenlen(\textcolor{keyword}{const}\ StringRef\ \&target);}
\DoxyCodeLine{00168\ }
\DoxyCodeLine{00169\ \textcolor{comment}{//\ Returns\ quotedString\ version\ of\ |target|.\ \ Currently,\ this\ function}}
\DoxyCodeLine{00170\ \textcolor{comment}{//\ just\ replace\ '"{}'\ with\ '\(\backslash\)"{}'.}}
\DoxyCodeLine{00171\ StringRef\ quote\_string(BlockAllocator\ \&balloc,\ \textcolor{keyword}{const}\ StringRef\ \&target);}
\DoxyCodeLine{00172\ }
\DoxyCodeLine{00173\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ OutputIt>}
\DoxyCodeLine{00174\ OutputIt\ quote\_string(OutputIt\ it,\ \textcolor{keyword}{const}\ StringRef\ \&target)\ \{}
\DoxyCodeLine{00175\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ c\ :\ target)\ \{}
\DoxyCodeLine{00176\ \ \ \ \ \textcolor{keywordflow}{if}\ (c\ ==\ \textcolor{charliteral}{'"{}'})\ \{}
\DoxyCodeLine{00177\ \ \ \ \ \ \ *it++\ =\ \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'};}
\DoxyCodeLine{00178\ \ \ \ \ \ \ *it++\ =\ \textcolor{charliteral}{'"{}'};}
\DoxyCodeLine{00179\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00180\ \ \ \ \ \ \ *it++\ =\ c;}
\DoxyCodeLine{00181\ \ \ \ \ \}}
\DoxyCodeLine{00182\ \ \ \}}
\DoxyCodeLine{00183\ }
\DoxyCodeLine{00184\ \ \ \textcolor{keywordflow}{return}\ it;}
\DoxyCodeLine{00185\ \}}
\DoxyCodeLine{00186\ }
\DoxyCodeLine{00187\ \textcolor{comment}{//\ Returns\ the\ number\ of\ bytes\ written\ by\ quote\_string\ with\ the\ same}}
\DoxyCodeLine{00188\ \textcolor{comment}{//\ |target|\ parameter.\ \ The\ return\ value\ does\ not\ include\ a\ terminal}}
\DoxyCodeLine{00189\ \textcolor{comment}{//\ NUL\ byte.}}
\DoxyCodeLine{00190\ \textcolor{keywordtype}{size\_t}\ quote\_stringlen(\textcolor{keyword}{const}\ StringRef\ \&target);}
\DoxyCodeLine{00191\ }
\DoxyCodeLine{00192\ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{char}\ LOWER\_XDIGITS[]\ =\ \textcolor{stringliteral}{"{}0123456789abcdef"{}};}
\DoxyCodeLine{00193\ }
\DoxyCodeLine{00194\ \textcolor{keyword}{template}\ <std::weakly\_incrementable\ OutputIt>}
\DoxyCodeLine{00195\ OutputIt\ format\_hex(OutputIt\ it,\ std::span<const\ uint8\_t>\ s)\ \{}
\DoxyCodeLine{00196\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ c\ :\ s)\ \{}
\DoxyCodeLine{00197\ \ \ \ \ *it++\ =\ LOWER\_XDIGITS[c\ >>\ 4];}
\DoxyCodeLine{00198\ \ \ \ \ *it++\ =\ LOWER\_XDIGITS[c\ \&\ 0xf];}
\DoxyCodeLine{00199\ \ \ \}}
\DoxyCodeLine{00200\ }
\DoxyCodeLine{00201\ \ \ \textcolor{keywordflow}{return}\ it;}
\DoxyCodeLine{00202\ \}}
\DoxyCodeLine{00203\ }
\DoxyCodeLine{00204\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{size\_t}\ N\ =\ std::dynamic\_extent,}
\DoxyCodeLine{00205\ \ \ \ \ \ \ \ \ \ \ std::weakly\_incrementable\ OutputIt>}
\DoxyCodeLine{00206\ OutputIt\ format\_hex(OutputIt\ it,\ std::span<T,\ N>\ s)\ \{}
\DoxyCodeLine{00207\ \ \ \textcolor{keywordflow}{return}\ format\_hex(it,\ std::span<const\ uint8\_t>\{as\_uint8\_span(s)\});}
\DoxyCodeLine{00208\ \}}
\DoxyCodeLine{00209\ }
\DoxyCodeLine{00210\ std::string\ format\_hex(std::span<const\ uint8\_t>\ s);}
\DoxyCodeLine{00211\ }
\DoxyCodeLine{00212\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{size\_t}\ N\ =\ std::dynamic\_extent>}
\DoxyCodeLine{00213\ std::string\ format\_hex(std::span<T,\ N>\ s)\ \{}
\DoxyCodeLine{00214\ \ \ \textcolor{keywordflow}{return}\ format\_hex(std::span<const\ uint8\_t>\{as\_uint8\_span(s)\});}
\DoxyCodeLine{00215\ \}}
\DoxyCodeLine{00216\ }
\DoxyCodeLine{00217\ StringRef\ format\_hex(BlockAllocator\ \&balloc,\ std::span<const\ uint8\_t>\ s);}
\DoxyCodeLine{00218\ }
\DoxyCodeLine{00219\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{size\_t}\ N\ =\ std::dynamic\_extent>}
\DoxyCodeLine{00220\ StringRef\ format\_hex(BlockAllocator\ \&balloc,\ std::span<T,\ N>\ s)\ \{}
\DoxyCodeLine{00221\ \ \ \textcolor{keywordflow}{return}\ format\_hex(balloc,\ std::span<const\ uint8\_t>\{as\_uint8\_span(s)\});}
\DoxyCodeLine{00222\ \}}
\DoxyCodeLine{00223\ }
\DoxyCodeLine{00224\ \textcolor{comment}{//\ decode\_hex\ decodes\ hex\ string\ |s|,\ returns\ the\ decoded\ byte\ string.}}
\DoxyCodeLine{00225\ \textcolor{comment}{//\ This\ function\ assumes\ |s|\ is\ hex\ string,\ that\ is\ is\_hex\_string(s)}}
\DoxyCodeLine{00226\ \textcolor{comment}{//\ ==\ true.}}
\DoxyCodeLine{00227\ std::span<const\ uint8\_t>\ decode\_hex(BlockAllocator\ \&balloc,\ \textcolor{keyword}{const}\ StringRef\ \&s);}
\DoxyCodeLine{00228\ }
\DoxyCodeLine{00229\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ OutputIt>}
\DoxyCodeLine{00230\ OutputIt\ decode\_hex(OutputIt\ d\_first,\ \textcolor{keyword}{const}\ StringRef\ \&s)\ \{}
\DoxyCodeLine{00231\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ it\ =\ std::begin(s);\ it\ !=\ std::end(s);\ it\ +=\ 2)\ \{}
\DoxyCodeLine{00232\ \ \ \ \ *d\_first++\ =\ (hex\_to\_uint(*it)\ <<\ 4)\ |\ hex\_to\_uint(*(it\ +\ 1));}
\DoxyCodeLine{00233\ \ \ \}}
\DoxyCodeLine{00234\ }
\DoxyCodeLine{00235\ \ \ \textcolor{keywordflow}{return}\ d\_first;}
\DoxyCodeLine{00236\ \}}
\DoxyCodeLine{00237\ }
\DoxyCodeLine{00238\ \textcolor{comment}{//\ Returns\ given\ time\ |t|\ from\ epoch\ in\ HTTP\ Date\ format\ (e.g.,\ Mon,}}
\DoxyCodeLine{00239\ \textcolor{comment}{//\ 10\ Oct\ 2016\ 10:25:58\ GMT).}}
\DoxyCodeLine{00240\ std::string\ http\_date(time\_t\ t);}
\DoxyCodeLine{00241\ \textcolor{comment}{//\ Writes\ given\ time\ |t|\ from\ epoch\ in\ HTTP\ Date\ format\ into\ the}}
\DoxyCodeLine{00242\ \textcolor{comment}{//\ buffer\ pointed\ by\ |res|.\ \ The\ buffer\ must\ be\ at\ least\ 29\ bytes}}
\DoxyCodeLine{00243\ \textcolor{comment}{//\ long.\ \ This\ function\ returns\ the\ one\ beyond\ the\ last\ position.}}
\DoxyCodeLine{00244\ \textcolor{keywordtype}{char}\ *http\_date(\textcolor{keywordtype}{char}\ *res,\ time\_t\ t);}
\DoxyCodeLine{00245\ }
\DoxyCodeLine{00246\ \textcolor{comment}{//\ Returns\ given\ time\ |t|\ from\ epoch\ in\ Common\ Log\ format\ (e.g.,}}
\DoxyCodeLine{00247\ \textcolor{comment}{//\ 03/Jul/2014:00:19:38\ +0900)}}
\DoxyCodeLine{00248\ std::string\ common\_log\_date(time\_t\ t);}
\DoxyCodeLine{00249\ \textcolor{comment}{//\ Writes\ given\ time\ |t|\ from\ epoch\ in\ Common\ Log\ format\ into\ the}}
\DoxyCodeLine{00250\ \textcolor{comment}{//\ buffer\ pointed\ by\ |res|.\ \ The\ buffer\ must\ be\ at\ least\ 26\ bytes}}
\DoxyCodeLine{00251\ \textcolor{comment}{//\ long.\ \ This\ function\ returns\ the\ one\ beyond\ the\ last\ position.}}
\DoxyCodeLine{00252\ \textcolor{keywordtype}{char}\ *common\_log\_date(\textcolor{keywordtype}{char}\ *res,\ time\_t\ t);}
\DoxyCodeLine{00253\ }
\DoxyCodeLine{00254\ \textcolor{comment}{//\ Returns\ given\ millisecond\ |ms|\ from\ epoch\ in\ ISO\ 8601\ format\ (e.g.,}}
\DoxyCodeLine{00255\ \textcolor{comment}{//\ 2014-\/11-\/15T12:58:24.741Z\ or\ 2014-\/11-\/15T12:58:24.741+09:00)}}
\DoxyCodeLine{00256\ std::string\ iso8601\_date(int64\_t\ ms);}
\DoxyCodeLine{00257\ \textcolor{comment}{//\ Writes\ given\ time\ |t|\ from\ epoch\ in\ ISO\ 8601\ format\ into\ the\ buffer}}
\DoxyCodeLine{00258\ \textcolor{comment}{//\ pointed\ by\ |res|.\ \ The\ buffer\ must\ be\ at\ least\ 29\ bytes\ long.\ \ This}}
\DoxyCodeLine{00259\ \textcolor{comment}{//\ function\ returns\ the\ one\ beyond\ the\ last\ position.}}
\DoxyCodeLine{00260\ \textcolor{keywordtype}{char}\ *iso8601\_date(\textcolor{keywordtype}{char}\ *res,\ int64\_t\ ms);}
\DoxyCodeLine{00261\ }
\DoxyCodeLine{00262\ \textcolor{comment}{//\ Writes\ given\ time\ |t|\ from\ epoch\ in\ ISO\ 8601\ basic\ format\ into\ the}}
\DoxyCodeLine{00263\ \textcolor{comment}{//\ buffer\ pointed\ by\ |res|.\ \ The\ buffer\ must\ be\ at\ least\ 24\ bytes}}
\DoxyCodeLine{00264\ \textcolor{comment}{//\ long.\ \ This\ function\ returns\ the\ one\ beyond\ the\ last\ position.}}
\DoxyCodeLine{00265\ \textcolor{keywordtype}{char}\ *iso8601\_basic\_date(\textcolor{keywordtype}{char}\ *res,\ int64\_t\ ms);}
\DoxyCodeLine{00266\ }
\DoxyCodeLine{00267\ time\_t\ parse\_http\_date(\textcolor{keyword}{const}\ StringRef\ \&s);}
\DoxyCodeLine{00268\ }
\DoxyCodeLine{00269\ \textcolor{comment}{//\ Parses\ time\ formatted\ as\ "{}MMM\ DD\ HH:MM:SS\ YYYY\ [GMT]"{}\ (e.g.,\ Feb\ 3}}
\DoxyCodeLine{00270\ \textcolor{comment}{//\ 00:55:52\ 2015\ GMT),\ which\ is\ specifically\ used\ by\ OpenSSL}}
\DoxyCodeLine{00271\ \textcolor{comment}{//\ ASN1\_TIME\_print().}}
\DoxyCodeLine{00272\ time\_t\ parse\_openssl\_asn1\_time\_print(\textcolor{keyword}{const}\ StringRef\ \&s);}
\DoxyCodeLine{00273\ }
\DoxyCodeLine{00274\ \textcolor{keywordtype}{char}\ upcase(\textcolor{keywordtype}{char}\ c);}
\DoxyCodeLine{00275\ }
\DoxyCodeLine{00276\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{char}\ lowcase(\textcolor{keywordtype}{char}\ c)\ \{}
\DoxyCodeLine{00277\ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{static}\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}\ tbl[]\ =\ \{}
\DoxyCodeLine{00278\ \ \ \ \ 0,\ \ \ 1,\ \ \ 2,\ \ \ 3,\ \ \ 4,\ \ \ 5,\ \ \ 6,\ \ \ 7,\ \ \ 8,\ \ \ 9,\ \ \ 10,\ \ 11,\ \ 12,\ \ 13,\ \ 14,}
\DoxyCodeLine{00279\ \ \ \ \ 15,\ \ 16,\ \ 17,\ \ 18,\ \ 19,\ \ 20,\ \ 21,\ \ 22,\ \ 23,\ \ 24,\ \ 25,\ \ 26,\ \ 27,\ \ 28,\ \ 29,}
\DoxyCodeLine{00280\ \ \ \ \ 30,\ \ 31,\ \ 32,\ \ 33,\ \ 34,\ \ 35,\ \ 36,\ \ 37,\ \ 38,\ \ 39,\ \ 40,\ \ 41,\ \ 42,\ \ 43,\ \ 44,}
\DoxyCodeLine{00281\ \ \ \ \ 45,\ \ 46,\ \ 47,\ \ 48,\ \ 49,\ \ 50,\ \ 51,\ \ 52,\ \ 53,\ \ 54,\ \ 55,\ \ 56,\ \ 57,\ \ 58,\ \ 59,}
\DoxyCodeLine{00282\ \ \ \ \ 60,\ \ 61,\ \ 62,\ \ 63,\ \ 64,\ \ \textcolor{charliteral}{'a'},\ \textcolor{charliteral}{'b'},\ \textcolor{charliteral}{'c'},\ \textcolor{charliteral}{'d'},\ \textcolor{charliteral}{'e'},\ \textcolor{charliteral}{'f'},\ \textcolor{charliteral}{'g'},\ \textcolor{charliteral}{'h'},\ \textcolor{charliteral}{'i'},\ \textcolor{charliteral}{'j'},}
\DoxyCodeLine{00283\ \ \ \ \ \textcolor{charliteral}{'k'},\ \textcolor{charliteral}{'l'},\ \textcolor{charliteral}{'m'},\ \textcolor{charliteral}{'n'},\ \textcolor{charliteral}{'o'},\ \textcolor{charliteral}{'p'},\ \textcolor{charliteral}{'q'},\ \textcolor{charliteral}{'r'},\ \textcolor{charliteral}{'s'},\ \textcolor{charliteral}{'t'},\ \textcolor{charliteral}{'u'},\ \textcolor{charliteral}{'v'},\ \textcolor{charliteral}{'w'},\ \textcolor{charliteral}{'x'},\ \textcolor{charliteral}{'y'},}
\DoxyCodeLine{00284\ \ \ \ \ \textcolor{charliteral}{'z'},\ 91,\ \ 92,\ \ 93,\ \ 94,\ \ 95,\ \ 96,\ \ 97,\ \ 98,\ \ 99,\ \ 100,\ 101,\ 102,\ 103,\ 104,}
\DoxyCodeLine{00285\ \ \ \ \ 105,\ 106,\ 107,\ 108,\ 109,\ 110,\ 111,\ 112,\ 113,\ 114,\ 115,\ 116,\ 117,\ 118,\ 119,}
\DoxyCodeLine{00286\ \ \ \ \ 120,\ 121,\ 122,\ 123,\ 124,\ 125,\ 126,\ 127,\ 128,\ 129,\ 130,\ 131,\ 132,\ 133,\ 134,}
\DoxyCodeLine{00287\ \ \ \ \ 135,\ 136,\ 137,\ 138,\ 139,\ 140,\ 141,\ 142,\ 143,\ 144,\ 145,\ 146,\ 147,\ 148,\ 149,}
\DoxyCodeLine{00288\ \ \ \ \ 150,\ 151,\ 152,\ 153,\ 154,\ 155,\ 156,\ 157,\ 158,\ 159,\ 160,\ 161,\ 162,\ 163,\ 164,}
\DoxyCodeLine{00289\ \ \ \ \ 165,\ 166,\ 167,\ 168,\ 169,\ 170,\ 171,\ 172,\ 173,\ 174,\ 175,\ 176,\ 177,\ 178,\ 179,}
\DoxyCodeLine{00290\ \ \ \ \ 180,\ 181,\ 182,\ 183,\ 184,\ 185,\ 186,\ 187,\ 188,\ 189,\ 190,\ 191,\ 192,\ 193,\ 194,}
\DoxyCodeLine{00291\ \ \ \ \ 195,\ 196,\ 197,\ 198,\ 199,\ 200,\ 201,\ 202,\ 203,\ 204,\ 205,\ 206,\ 207,\ 208,\ 209,}
\DoxyCodeLine{00292\ \ \ \ \ 210,\ 211,\ 212,\ 213,\ 214,\ 215,\ 216,\ 217,\ 218,\ 219,\ 220,\ 221,\ 222,\ 223,\ 224,}
\DoxyCodeLine{00293\ \ \ \ \ 225,\ 226,\ 227,\ 228,\ 229,\ 230,\ 231,\ 232,\ 233,\ 234,\ 235,\ 236,\ 237,\ 238,\ 239,}
\DoxyCodeLine{00294\ \ \ \ \ 240,\ 241,\ 242,\ 243,\ 244,\ 245,\ 246,\ 247,\ 248,\ 249,\ 250,\ 251,\ 252,\ 253,\ 254,}
\DoxyCodeLine{00295\ \ \ \ \ 255,}
\DoxyCodeLine{00296\ \ \ \};}
\DoxyCodeLine{00297\ \ \ \textcolor{keywordflow}{return}\ tbl[\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}\textcolor{keyword}{>}(c)];}
\DoxyCodeLine{00298\ \}}
\DoxyCodeLine{00299\ }
\DoxyCodeLine{00300\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InputIterator1,\ \textcolor{keyword}{typename}\ InputIterator2>}
\DoxyCodeLine{00301\ \textcolor{keywordtype}{bool}\ starts\_with(InputIterator1\ first1,\ InputIterator1\ last1,}
\DoxyCodeLine{00302\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ InputIterator2\ first2,\ InputIterator2\ last2)\ \{}
\DoxyCodeLine{00303\ \ \ \textcolor{keywordflow}{return}\ std::distance(first1,\ last1)\ >=\ std::distance(first2,\ last2)\ \&\&}
\DoxyCodeLine{00304\ \ \ \ \ \ \ \ \ \ std::equal(first2,\ last2,\ first1);}
\DoxyCodeLine{00305\ \}}
\DoxyCodeLine{00306\ }
\DoxyCodeLine{00307\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ S,\ \textcolor{keyword}{typename}\ T>\ \textcolor{keywordtype}{bool}\ starts\_with(\textcolor{keyword}{const}\ S\ \&a,\ \textcolor{keyword}{const}\ T\ \&b)\ \{}
\DoxyCodeLine{00308\ \ \ \textcolor{keywordflow}{return}\ starts\_with(std::begin(a),\ std::end(a),\ std::begin(b),\ std::end(b));}
\DoxyCodeLine{00309\ \}}
\DoxyCodeLine{00310\ }
\DoxyCodeLine{00311\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structnghttp2_1_1util_1_1CaseCmp}{CaseCmp}}\ \{}
\DoxyCodeLine{00312\ \ \ \textcolor{keywordtype}{bool}\ operator()(\textcolor{keywordtype}{char}\ lhs,\ \textcolor{keywordtype}{char}\ rhs)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00313\ \ \ \ \ \textcolor{keywordflow}{return}\ lowcase(lhs)\ ==\ lowcase(rhs);}
\DoxyCodeLine{00314\ \ \ \}}
\DoxyCodeLine{00315\ \};}
\DoxyCodeLine{00316\ }
\DoxyCodeLine{00317\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InputIterator1,\ \textcolor{keyword}{typename}\ InputIterator2>}
\DoxyCodeLine{00318\ \textcolor{keywordtype}{bool}\ istarts\_with(InputIterator1\ first1,\ InputIterator1\ last1,}
\DoxyCodeLine{00319\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ InputIterator2\ first2,\ InputIterator2\ last2)\ \{}
\DoxyCodeLine{00320\ \ \ \textcolor{keywordflow}{return}\ std::distance(first1,\ last1)\ >=\ std::distance(first2,\ last2)\ \&\&}
\DoxyCodeLine{00321\ \ \ \ \ \ \ \ \ \ std::equal(first2,\ last2,\ first1,\ \mbox{\hyperlink{structnghttp2_1_1util_1_1CaseCmp}{CaseCmp}}());}
\DoxyCodeLine{00322\ \}}
\DoxyCodeLine{00323\ }
\DoxyCodeLine{00324\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ S,\ \textcolor{keyword}{typename}\ T>\ \textcolor{keywordtype}{bool}\ istarts\_with(\textcolor{keyword}{const}\ S\ \&a,\ \textcolor{keyword}{const}\ T\ \&b)\ \{}
\DoxyCodeLine{00325\ \ \ \textcolor{keywordflow}{return}\ istarts\_with(std::begin(a),\ std::end(a),\ std::begin(b),\ std::end(b));}
\DoxyCodeLine{00326\ \}}
\DoxyCodeLine{00327\ }
\DoxyCodeLine{00328\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InputIterator1,\ \textcolor{keyword}{typename}\ InputIterator2>}
\DoxyCodeLine{00329\ \textcolor{keywordtype}{bool}\ ends\_with(InputIterator1\ first1,\ InputIterator1\ last1,}
\DoxyCodeLine{00330\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ InputIterator2\ first2,\ InputIterator2\ last2)\ \{}
\DoxyCodeLine{00331\ \ \ \textcolor{keyword}{auto}\ len1\ =\ std::distance(first1,\ last1);}
\DoxyCodeLine{00332\ \ \ \textcolor{keyword}{auto}\ len2\ =\ std::distance(first2,\ last2);}
\DoxyCodeLine{00333\ }
\DoxyCodeLine{00334\ \ \ \textcolor{keywordflow}{return}\ len1\ >=\ len2\ \&\&\ std::equal(first2,\ last2,\ first1\ +\ (len1\ -\/\ len2));}
\DoxyCodeLine{00335\ \}}
\DoxyCodeLine{00336\ }
\DoxyCodeLine{00337\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ S>\ \textcolor{keywordtype}{bool}\ ends\_with(\textcolor{keyword}{const}\ T\ \&a,\ \textcolor{keyword}{const}\ S\ \&b)\ \{}
\DoxyCodeLine{00338\ \ \ \textcolor{keywordflow}{return}\ ends\_with(std::begin(a),\ std::end(a),\ std::begin(b),\ std::end(b));}
\DoxyCodeLine{00339\ \}}
\DoxyCodeLine{00340\ }
\DoxyCodeLine{00341\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InputIterator1,\ \textcolor{keyword}{typename}\ InputIterator2>}
\DoxyCodeLine{00342\ \textcolor{keywordtype}{bool}\ iends\_with(InputIterator1\ first1,\ InputIterator1\ last1,}
\DoxyCodeLine{00343\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ InputIterator2\ first2,\ InputIterator2\ last2)\ \{}
\DoxyCodeLine{00344\ \ \ \textcolor{keyword}{auto}\ len1\ =\ std::distance(first1,\ last1);}
\DoxyCodeLine{00345\ \ \ \textcolor{keyword}{auto}\ len2\ =\ std::distance(first2,\ last2);}
\DoxyCodeLine{00346\ }
\DoxyCodeLine{00347\ \ \ \textcolor{keywordflow}{return}\ len1\ >=\ len2\ \&\&}
\DoxyCodeLine{00348\ \ \ \ \ \ \ \ \ \ std::equal(first2,\ last2,\ first1\ +\ (len1\ -\/\ len2),\ \mbox{\hyperlink{structnghttp2_1_1util_1_1CaseCmp}{CaseCmp}}());}
\DoxyCodeLine{00349\ \}}
\DoxyCodeLine{00350\ }
\DoxyCodeLine{00351\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ S>\ \textcolor{keywordtype}{bool}\ iends\_with(\textcolor{keyword}{const}\ T\ \&a,\ \textcolor{keyword}{const}\ S\ \&b)\ \{}
\DoxyCodeLine{00352\ \ \ \textcolor{keywordflow}{return}\ iends\_with(std::begin(a),\ std::end(a),\ std::begin(b),\ std::end(b));}
\DoxyCodeLine{00353\ \}}
\DoxyCodeLine{00354\ }
\DoxyCodeLine{00355\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InputIt1,\ \textcolor{keyword}{typename}\ InputIt2>}
\DoxyCodeLine{00356\ \textcolor{keywordtype}{bool}\ strieq(InputIt1\ first1,\ InputIt1\ last1,\ InputIt2\ first2,\ InputIt2\ last2)\ \{}
\DoxyCodeLine{00357\ \ \ \textcolor{keywordflow}{return}\ std::equal(first1,\ last1,\ first2,\ last2,\ \mbox{\hyperlink{structnghttp2_1_1util_1_1CaseCmp}{CaseCmp}}());}
\DoxyCodeLine{00358\ \}}
\DoxyCodeLine{00359\ }
\DoxyCodeLine{00360\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ S>\ \textcolor{keywordtype}{bool}\ strieq(\textcolor{keyword}{const}\ T\ \&a,\ \textcolor{keyword}{const}\ S\ \&b)\ \{}
\DoxyCodeLine{00361\ \ \ \textcolor{keywordflow}{return}\ strieq(std::begin(a),\ std::end(a),\ std::begin(b),\ std::end(b));}
\DoxyCodeLine{00362\ \}}
\DoxyCodeLine{00363\ }
\DoxyCodeLine{00364\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ S>}
\DoxyCodeLine{00365\ \textcolor{keywordtype}{bool}\ strieq(\textcolor{keyword}{const}\ T\ \&a,\ \textcolor{keyword}{const}\ S\ \&b,\ \textcolor{keywordtype}{size\_t}\ blen)\ \{}
\DoxyCodeLine{00366\ \ \ \textcolor{keywordflow}{return}\ std::equal(std::begin(a),\ std::end(a),\ std::begin(b),}
\DoxyCodeLine{00367\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::next(std::begin(b),\ blen),\ \mbox{\hyperlink{structnghttp2_1_1util_1_1CaseCmp}{CaseCmp}}());}
\DoxyCodeLine{00368\ \}}
\DoxyCodeLine{00369\ }
\DoxyCodeLine{00370\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ S>}
\DoxyCodeLine{00371\ \textcolor{keywordtype}{bool}\ streq(\textcolor{keyword}{const}\ T\ \&a,\ \textcolor{keyword}{const}\ S\ \&b,\ \textcolor{keywordtype}{size\_t}\ blen)\ \{}
\DoxyCodeLine{00372\ \ \ \textcolor{keywordflow}{return}\ std::equal(std::begin(a),\ std::end(a),\ std::begin(b),}
\DoxyCodeLine{00373\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::next(std::begin(b),\ blen));}
\DoxyCodeLine{00374\ \}}
\DoxyCodeLine{00375\ }
\DoxyCodeLine{00376\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InputIt>\ \textcolor{keywordtype}{void}\ inp\_strlower(InputIt\ first,\ InputIt\ last)\ \{}
\DoxyCodeLine{00377\ \ \ std::transform(first,\ last,\ first,\ lowcase);}
\DoxyCodeLine{00378\ \}}
\DoxyCodeLine{00379\ }
\DoxyCodeLine{00380\ \textcolor{comment}{//\ Lowercase\ |s|\ in\ place.}}
\DoxyCodeLine{00381\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ inp\_strlower(std::string\ \&s)\ \{}
\DoxyCodeLine{00382\ \ \ inp\_strlower(std::begin(s),\ std::end(s));}
\DoxyCodeLine{00383\ \}}
\DoxyCodeLine{00384\ }
\DoxyCodeLine{00385\ \textcolor{comment}{//\ Returns\ string\ representation\ of\ |n|\ with\ 2\ fractional\ digits.}}
\DoxyCodeLine{00386\ std::string\ dtos(\textcolor{keywordtype}{double}\ n);}
\DoxyCodeLine{00387\ }
\DoxyCodeLine{00388\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>\ std::string\ utos(T\ n)\ \{}
\DoxyCodeLine{00389\ \ \ std::string\ res;}
\DoxyCodeLine{00390\ \ \ \textcolor{keywordflow}{if}\ (n\ ==\ 0)\ \{}
\DoxyCodeLine{00391\ \ \ \ \ res\ =\ \textcolor{stringliteral}{"{}0"{}};}
\DoxyCodeLine{00392\ \ \ \ \ \textcolor{keywordflow}{return}\ res;}
\DoxyCodeLine{00393\ \ \ \}}
\DoxyCodeLine{00394\ \ \ \textcolor{keywordtype}{size\_t}\ nlen\ =\ 0;}
\DoxyCodeLine{00395\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ t\ =\ n;\ t;\ t\ /=\ 10,\ ++nlen)}
\DoxyCodeLine{00396\ \ \ \ \ ;}
\DoxyCodeLine{00397\ \ \ res.resize(nlen);}
\DoxyCodeLine{00398\ \ \ \textcolor{keywordflow}{for}\ (;\ n;\ n\ /=\ 10)\ \{}
\DoxyCodeLine{00399\ \ \ \ \ res[-\/-\/nlen]\ =\ (n\ \%\ 10)\ +\ \textcolor{charliteral}{'0'};}
\DoxyCodeLine{00400\ \ \ \}}
\DoxyCodeLine{00401\ \ \ \textcolor{keywordflow}{return}\ res;}
\DoxyCodeLine{00402\ \}}
\DoxyCodeLine{00403\ }
\DoxyCodeLine{00404\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ OutputIt>\ OutputIt\ utos(OutputIt\ dst,\ T\ n)\ \{}
\DoxyCodeLine{00405\ \ \ \textcolor{keywordflow}{if}\ (n\ ==\ 0)\ \{}
\DoxyCodeLine{00406\ \ \ \ \ *dst++\ =\ \textcolor{charliteral}{'0'};}
\DoxyCodeLine{00407\ \ \ \ \ \textcolor{keywordflow}{return}\ dst;}
\DoxyCodeLine{00408\ \ \ \}}
\DoxyCodeLine{00409\ \ \ \textcolor{keywordtype}{size\_t}\ nlen\ =\ 0;}
\DoxyCodeLine{00410\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ t\ =\ n;\ t;\ t\ /=\ 10,\ ++nlen)}
\DoxyCodeLine{00411\ \ \ \ \ ;}
\DoxyCodeLine{00412\ \ \ \textcolor{keyword}{auto}\ p\ =\ dst\ +\ nlen;}
\DoxyCodeLine{00413\ \ \ \textcolor{keyword}{auto}\ res\ =\ p;}
\DoxyCodeLine{00414\ \ \ \textcolor{keywordflow}{for}\ (;\ n;\ n\ /=\ 10)\ \{}
\DoxyCodeLine{00415\ \ \ \ \ *-\/-\/p\ =\ (n\ \%\ 10)\ +\ \textcolor{charliteral}{'0'};}
\DoxyCodeLine{00416\ \ \ \}}
\DoxyCodeLine{00417\ \ \ \textcolor{keywordflow}{return}\ res;}
\DoxyCodeLine{00418\ \}}
\DoxyCodeLine{00419\ }
\DoxyCodeLine{00420\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00421\ StringRef\ make\_string\_ref\_uint(BlockAllocator\ \&balloc,\ T\ n)\ \{}
\DoxyCodeLine{00422\ \ \ \textcolor{keyword}{auto}\ iov\ =\ make\_byte\_ref(balloc,\ NGHTTP2\_MAX\_UINT64\_DIGITS\ +\ 1);}
\DoxyCodeLine{00423\ \ \ \textcolor{keyword}{auto}\ p\ =\ std::begin(iov);}
\DoxyCodeLine{00424\ \ \ p\ =\ util::utos(p,\ n);}
\DoxyCodeLine{00425\ \ \ *p\ =\ \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{00426\ \ \ \textcolor{keywordflow}{return}\ StringRef\{std::span\{std::begin(iov),\ p\}\};}
\DoxyCodeLine{00427\ \}}
\DoxyCodeLine{00428\ }
\DoxyCodeLine{00429\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>\ std::string\ utos\_unit(T\ n)\ \{}
\DoxyCodeLine{00430\ \ \ \textcolor{keywordtype}{char}\ u\ =\ 0;}
\DoxyCodeLine{00431\ \ \ \textcolor{keywordflow}{if}\ (n\ >=\ (1\ <<\ 30))\ \{}
\DoxyCodeLine{00432\ \ \ \ \ u\ =\ \textcolor{charliteral}{'G'};}
\DoxyCodeLine{00433\ \ \ \ \ n\ /=\ (1\ <<\ 30);}
\DoxyCodeLine{00434\ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (n\ >=\ (1\ <<\ 20))\ \{}
\DoxyCodeLine{00435\ \ \ \ \ u\ =\ \textcolor{charliteral}{'M'};}
\DoxyCodeLine{00436\ \ \ \ \ n\ /=\ (1\ <<\ 20);}
\DoxyCodeLine{00437\ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (n\ >=\ (1\ <<\ 10))\ \{}
\DoxyCodeLine{00438\ \ \ \ \ u\ =\ \textcolor{charliteral}{'K'};}
\DoxyCodeLine{00439\ \ \ \ \ n\ /=\ (1\ <<\ 10);}
\DoxyCodeLine{00440\ \ \ \}}
\DoxyCodeLine{00441\ \ \ \textcolor{keywordflow}{if}\ (u\ ==\ 0)\ \{}
\DoxyCodeLine{00442\ \ \ \ \ \textcolor{keywordflow}{return}\ utos(n);}
\DoxyCodeLine{00443\ \ \ \}}
\DoxyCodeLine{00444\ \ \ \textcolor{keywordflow}{return}\ utos(n)\ +\ u;}
\DoxyCodeLine{00445\ \}}
\DoxyCodeLine{00446\ }
\DoxyCodeLine{00447\ \textcolor{comment}{//\ Like\ utos\_unit(),\ but\ 2\ digits\ fraction\ part\ is\ followed.}}
\DoxyCodeLine{00448\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>\ std::string\ utos\_funit(T\ n)\ \{}
\DoxyCodeLine{00449\ \ \ \textcolor{keywordtype}{char}\ u\ =\ 0;}
\DoxyCodeLine{00450\ \ \ \textcolor{keywordtype}{int}\ b\ =\ 0;}
\DoxyCodeLine{00451\ \ \ \textcolor{keywordflow}{if}\ (n\ >=\ (1\ <<\ 30))\ \{}
\DoxyCodeLine{00452\ \ \ \ \ u\ =\ \textcolor{charliteral}{'G'};}
\DoxyCodeLine{00453\ \ \ \ \ b\ =\ 30;}
\DoxyCodeLine{00454\ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (n\ >=\ (1\ <<\ 20))\ \{}
\DoxyCodeLine{00455\ \ \ \ \ u\ =\ \textcolor{charliteral}{'M'};}
\DoxyCodeLine{00456\ \ \ \ \ b\ =\ 20;}
\DoxyCodeLine{00457\ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (n\ >=\ (1\ <<\ 10))\ \{}
\DoxyCodeLine{00458\ \ \ \ \ u\ =\ \textcolor{charliteral}{'K'};}
\DoxyCodeLine{00459\ \ \ \ \ b\ =\ 10;}
\DoxyCodeLine{00460\ \ \ \}}
\DoxyCodeLine{00461\ \ \ \textcolor{keywordflow}{if}\ (b\ ==\ 0)\ \{}
\DoxyCodeLine{00462\ \ \ \ \ \textcolor{keywordflow}{return}\ utos(n);}
\DoxyCodeLine{00463\ \ \ \}}
\DoxyCodeLine{00464\ \ \ \textcolor{keywordflow}{return}\ dtos(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(n)\ /\ (1\ <<\ b))\ +\ u;}
\DoxyCodeLine{00465\ \}}
\DoxyCodeLine{00466\ }
\DoxyCodeLine{00467\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>\ std::string\ utox(T\ n)\ \{}
\DoxyCodeLine{00468\ \ \ std::string\ res;}
\DoxyCodeLine{00469\ \ \ \textcolor{keywordflow}{if}\ (n\ ==\ 0)\ \{}
\DoxyCodeLine{00470\ \ \ \ \ res\ =\ \textcolor{stringliteral}{"{}0"{}};}
\DoxyCodeLine{00471\ \ \ \ \ \textcolor{keywordflow}{return}\ res;}
\DoxyCodeLine{00472\ \ \ \}}
\DoxyCodeLine{00473\ \ \ \textcolor{keywordtype}{int}\ i\ =\ 0;}
\DoxyCodeLine{00474\ \ \ T\ t\ =\ n;}
\DoxyCodeLine{00475\ \ \ \textcolor{keywordflow}{for}\ (;\ t;\ t\ /=\ 16,\ ++i)}
\DoxyCodeLine{00476\ \ \ \ \ ;}
\DoxyCodeLine{00477\ \ \ res.resize(i);}
\DoxyCodeLine{00478\ \ \ -\/-\/i;}
\DoxyCodeLine{00479\ \ \ \textcolor{keywordflow}{for}\ (;\ n;\ -\/-\/i,\ n\ /=\ 16)\ \{}
\DoxyCodeLine{00480\ \ \ \ \ res[i]\ =\ UPPER\_XDIGITS[(n\ \&\ 0x0f)];}
\DoxyCodeLine{00481\ \ \ \}}
\DoxyCodeLine{00482\ \ \ \textcolor{keywordflow}{return}\ res;}
\DoxyCodeLine{00483\ \}}
\DoxyCodeLine{00484\ }
\DoxyCodeLine{00485\ \textcolor{keywordtype}{void}\ to\_token68(std::string\ \&base64str);}
\DoxyCodeLine{00486\ }
\DoxyCodeLine{00487\ StringRef\ to\_base64(BlockAllocator\ \&balloc,\ \textcolor{keyword}{const}\ StringRef\ \&token68str);}
\DoxyCodeLine{00488\ }
\DoxyCodeLine{00489\ \textcolor{keywordtype}{void}\ show\_candidates(\textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ *unkopt,\ \textcolor{keyword}{const}\ option\ *options);}
\DoxyCodeLine{00490\ }
\DoxyCodeLine{00491\ \textcolor{keywordtype}{bool}\ has\_uri\_field(\textcolor{keyword}{const}\ urlparse\_url\ \&u,\ urlparse\_url\_fields\ field);}
\DoxyCodeLine{00492\ }
\DoxyCodeLine{00493\ \textcolor{keywordtype}{bool}\ fieldeq(\textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ *uri1,\ \textcolor{keyword}{const}\ urlparse\_url\ \&u1,\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ *uri2,}
\DoxyCodeLine{00494\ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ urlparse\_url\ \&u2,\ urlparse\_url\_fields\ field);}
\DoxyCodeLine{00495\ }
\DoxyCodeLine{00496\ \textcolor{keywordtype}{bool}\ fieldeq(\textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ *uri,\ \textcolor{keyword}{const}\ urlparse\_url\ \&u,\ urlparse\_url\_fields\ field,}
\DoxyCodeLine{00497\ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ *t);}
\DoxyCodeLine{00498\ }
\DoxyCodeLine{00499\ \textcolor{keywordtype}{bool}\ fieldeq(\textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ *uri,\ \textcolor{keyword}{const}\ urlparse\_url\ \&u,\ urlparse\_url\_fields\ field,}
\DoxyCodeLine{00500\ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ StringRef\ \&t);}
\DoxyCodeLine{00501\ }
\DoxyCodeLine{00502\ StringRef\ get\_uri\_field(\textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ *uri,\ \textcolor{keyword}{const}\ urlparse\_url\ \&u,}
\DoxyCodeLine{00503\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ urlparse\_url\_fields\ field);}
\DoxyCodeLine{00504\ }
\DoxyCodeLine{00505\ uint16\_t\ get\_default\_port(\textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ *uri,\ \textcolor{keyword}{const}\ urlparse\_url\ \&u);}
\DoxyCodeLine{00506\ }
\DoxyCodeLine{00507\ \textcolor{keywordtype}{bool}\ porteq(\textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ *uri1,\ \textcolor{keyword}{const}\ urlparse\_url\ \&u1,\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ *uri2,}
\DoxyCodeLine{00508\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ urlparse\_url\ \&u2);}
\DoxyCodeLine{00509\ }
\DoxyCodeLine{00510\ \textcolor{keywordtype}{void}\ write\_uri\_field(std::ostream\ \&o,\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ *uri,\ \textcolor{keyword}{const}\ urlparse\_url\ \&u,}
\DoxyCodeLine{00511\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ urlparse\_url\_fields\ field);}
\DoxyCodeLine{00512\ }
\DoxyCodeLine{00513\ \textcolor{keywordtype}{bool}\ numeric\_host(\textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ *hostname);}
\DoxyCodeLine{00514\ }
\DoxyCodeLine{00515\ \textcolor{keywordtype}{bool}\ numeric\_host(\textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ *hostname,\ \textcolor{keywordtype}{int}\ family);}
\DoxyCodeLine{00516\ }
\DoxyCodeLine{00517\ \textcolor{comment}{//\ Returns\ numeric\ address\ string\ of\ |addr|.\ \ If\ getnameinfo()\ is}}
\DoxyCodeLine{00518\ \textcolor{comment}{//\ failed,\ "{}unknown"{}\ is\ returned.}}
\DoxyCodeLine{00519\ std::string\ numeric\_name(\textcolor{keyword}{const}\ \textcolor{keyword}{struct}\ sockaddr\ *sa,\ socklen\_t\ salen);}
\DoxyCodeLine{00520\ }
\DoxyCodeLine{00521\ \textcolor{comment}{//\ Returns\ string\ representation\ of\ numeric\ address\ and\ port\ of}}
\DoxyCodeLine{00522\ \textcolor{comment}{//\ |addr|.\ \ If\ address\ family\ is\ AF\_UNIX,\ this\ return\ path\ to\ UNIX}}
\DoxyCodeLine{00523\ \textcolor{comment}{//\ domain\ socket.\ \ Otherwise,\ the\ format\ is\ like\ <HOST>:<PORT>.\ \ For}}
\DoxyCodeLine{00524\ \textcolor{comment}{//\ IPv6\ address,\ address\ is\ enclosed\ by\ square\ brackets\ ([]).}}
\DoxyCodeLine{00525\ std::string\ to\_numeric\_addr(\textcolor{keyword}{const}\ Address\ *addr);}
\DoxyCodeLine{00526\ }
\DoxyCodeLine{00527\ std::string\ to\_numeric\_addr(\textcolor{keyword}{const}\ \textcolor{keyword}{struct}\ sockaddr\ *sa,\ socklen\_t\ salen);}
\DoxyCodeLine{00528\ }
\DoxyCodeLine{00529\ \textcolor{comment}{//\ Sets\ |port|\ to\ |addr|.}}
\DoxyCodeLine{00530\ \textcolor{keywordtype}{void}\ set\_port(Address\ \&addr,\ uint16\_t\ port);}
\DoxyCodeLine{00531\ }
\DoxyCodeLine{00532\ \textcolor{comment}{//\ Get\ port\ from\ |su|.}}
\DoxyCodeLine{00533\ uint16\_t\ get\_port(\textcolor{keyword}{const}\ sockaddr\_union\ *su);}
\DoxyCodeLine{00534\ }
\DoxyCodeLine{00535\ \textcolor{comment}{//\ Returns\ true\ if\ |port|\ is\ prohibited\ as\ a\ QUIC\ client\ port.}}
\DoxyCodeLine{00536\ \textcolor{keywordtype}{bool}\ quic\_prohibited\_port(uint16\_t\ port);}
\DoxyCodeLine{00537\ }
\DoxyCodeLine{00538\ \textcolor{comment}{//\ Returns\ ASCII\ dump\ of\ |data|\ of\ length\ |len|.\ \ Only\ ASCII\ printable}}
\DoxyCodeLine{00539\ \textcolor{comment}{//\ characters\ are\ preserved.\ \ Other\ characters\ are\ replaced\ with\ "{}."{}.}}
\DoxyCodeLine{00540\ std::string\ ascii\_dump(\textcolor{keyword}{const}\ uint8\_t\ *data,\ \textcolor{keywordtype}{size\_t}\ len);}
\DoxyCodeLine{00541\ }
\DoxyCodeLine{00542\ \textcolor{comment}{//\ Returns\ absolute\ path\ of\ executable\ path.\ \ If\ argc\ ==\ 0\ or\ |cwd|\ is}}
\DoxyCodeLine{00543\ \textcolor{comment}{//\ nullptr,\ this\ function\ returns\ nullptr.\ \ If\ argv[0]\ starts\ with}}
\DoxyCodeLine{00544\ \textcolor{comment}{//\ '/',\ this\ function\ returns\ argv[0].\ \ Otherwise\ return\ cwd\ +\ "{}/"{}\ +}}
\DoxyCodeLine{00545\ \textcolor{comment}{//\ argv[0].\ \ If\ non-\/null\ is\ returned,\ it\ is\ NULL-\/terminated\ string\ and}}
\DoxyCodeLine{00546\ \textcolor{comment}{//\ dynamically\ allocated\ by\ malloc.\ \ The\ caller\ is\ responsible\ to\ free}}
\DoxyCodeLine{00547\ \textcolor{comment}{//\ it.}}
\DoxyCodeLine{00548\ \textcolor{keywordtype}{char}\ *get\_exec\_path(\textcolor{keywordtype}{int}\ argc,\ \textcolor{keywordtype}{char}\ **\textcolor{keyword}{const}\ argv,\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ *cwd);}
\DoxyCodeLine{00549\ }
\DoxyCodeLine{00550\ \textcolor{comment}{//\ Validates\ path\ so\ that\ it\ does\ not\ contain\ directory\ traversal}}
\DoxyCodeLine{00551\ \textcolor{comment}{//\ vector.\ \ Returns\ true\ if\ path\ is\ safe.\ \ The\ |path|\ must\ start\ with}}
\DoxyCodeLine{00552\ \textcolor{comment}{//\ "{}/"{}\ otherwise\ returns\ false.\ \ This\ function\ should\ be\ called\ after}}
\DoxyCodeLine{00553\ \textcolor{comment}{//\ percent-\/decode\ was\ performed.}}
\DoxyCodeLine{00554\ \textcolor{keywordtype}{bool}\ check\_path(\textcolor{keyword}{const}\ std::string\ \&path);}
\DoxyCodeLine{00555\ }
\DoxyCodeLine{00556\ \textcolor{comment}{//\ Returns\ the\ |tv|\ value\ as\ 64\ bit\ integer\ using\ a\ microsecond\ as\ an}}
\DoxyCodeLine{00557\ \textcolor{comment}{//\ unit.}}
\DoxyCodeLine{00558\ int64\_t\ to\_time64(\textcolor{keyword}{const}\ timeval\ \&tv);}
\DoxyCodeLine{00559\ }
\DoxyCodeLine{00560\ \textcolor{comment}{//\ Returns\ true\ if\ ALPN\ ID\ |proto|\ is\ supported\ HTTP/2\ protocol}}
\DoxyCodeLine{00561\ \textcolor{comment}{//\ identifier.}}
\DoxyCodeLine{00562\ \textcolor{keywordtype}{bool}\ check\_h2\_is\_selected(\textcolor{keyword}{const}\ StringRef\ \&proto);}
\DoxyCodeLine{00563\ }
\DoxyCodeLine{00564\ \textcolor{comment}{//\ Selects\ h2\ protocol\ ALPN\ ID\ if\ one\ of\ supported\ h2\ versions\ are}}
\DoxyCodeLine{00565\ \textcolor{comment}{//\ present\ in\ |in|\ of\ length\ inlen.\ \ Returns\ true\ if\ h2\ version\ is}}
\DoxyCodeLine{00566\ \textcolor{comment}{//\ selected.}}
\DoxyCodeLine{00567\ \textcolor{keywordtype}{bool}\ select\_h2(\textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}\ **out,\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}\ *outlen,}
\DoxyCodeLine{00568\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}\ *in,\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{int}\ inlen);}
\DoxyCodeLine{00569\ }
\DoxyCodeLine{00570\ \textcolor{comment}{//\ Selects\ protocol\ ALPN\ ID\ if\ one\ of\ identifiers\ contained\ in\ |protolist|\ is}}
\DoxyCodeLine{00571\ \textcolor{comment}{//\ present\ in\ |in|\ of\ length\ inlen.\ \ Returns\ true\ if\ identifier\ is}}
\DoxyCodeLine{00572\ \textcolor{comment}{//\ selected.}}
\DoxyCodeLine{00573\ \textcolor{keywordtype}{bool}\ select\_protocol(\textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}\ **out,\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}\ *outlen,}
\DoxyCodeLine{00574\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}\ *in,\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{int}\ inlen,}
\DoxyCodeLine{00575\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<std::string>\ proto\_list);}
\DoxyCodeLine{00576\ }
\DoxyCodeLine{00577\ \textcolor{comment}{//\ Returns\ default\ ALPN\ protocol\ list,\ which\ only\ contains\ supported}}
\DoxyCodeLine{00578\ \textcolor{comment}{//\ HTTP/2\ protocol\ identifier.}}
\DoxyCodeLine{00579\ std::vector<unsigned\ char>\ get\_default\_alpn();}
\DoxyCodeLine{00580\ }
\DoxyCodeLine{00581\ \textcolor{comment}{//\ Parses\ delimited\ strings\ in\ |s|\ and\ returns\ the\ array\ of\ substring,}}
\DoxyCodeLine{00582\ \textcolor{comment}{//\ delimited\ by\ |delim|.\ \ The\ any\ white\ spaces\ around\ substring\ are}}
\DoxyCodeLine{00583\ \textcolor{comment}{//\ treated\ as\ a\ part\ of\ substring.}}
\DoxyCodeLine{00584\ std::vector<std::string>\ parse\_config\_str\_list(\textcolor{keyword}{const}\ StringRef\ \&s,}
\DoxyCodeLine{00585\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{char}\ delim\ =\ \textcolor{charliteral}{','});}
\DoxyCodeLine{00586\ }
\DoxyCodeLine{00587\ \textcolor{comment}{//\ Parses\ delimited\ strings\ in\ |s|\ and\ returns\ Substrings\ in\ |s|}}
\DoxyCodeLine{00588\ \textcolor{comment}{//\ delimited\ by\ |delim|.\ \ The\ any\ white\ spaces\ around\ substring\ are}}
\DoxyCodeLine{00589\ \textcolor{comment}{//\ treated\ as\ a\ part\ of\ substring.}}
\DoxyCodeLine{00590\ std::vector<StringRef>\ split\_str(\textcolor{keyword}{const}\ StringRef\ \&s,\ \textcolor{keywordtype}{char}\ delim);}
\DoxyCodeLine{00591\ }
\DoxyCodeLine{00592\ \textcolor{comment}{//\ Behaves\ like\ split\_str,\ but\ this\ variant\ splits\ at\ most\ |n|\ -\/\ 1}}
\DoxyCodeLine{00593\ \textcolor{comment}{//\ times\ and\ returns\ at\ most\ |n|\ sub-\/strings.\ \ If\ |n|\ is\ zero,\ it}}
\DoxyCodeLine{00594\ \textcolor{comment}{//\ falls\ back\ to\ split\_str.}}
\DoxyCodeLine{00595\ std::vector<StringRef>\ split\_str(\textcolor{keyword}{const}\ StringRef\ \&s,\ \textcolor{keywordtype}{char}\ delim,\ \textcolor{keywordtype}{size\_t}\ n);}
\DoxyCodeLine{00596\ }
\DoxyCodeLine{00597\ \textcolor{comment}{//\ Writes\ given\ time\ |tp|\ in\ Common\ Log\ format\ (e.g.,}}
\DoxyCodeLine{00598\ \textcolor{comment}{//\ 03/Jul/2014:00:19:38\ +0900)\ in\ buffer\ pointed\ by\ |out|.\ \ The\ buffer}}
\DoxyCodeLine{00599\ \textcolor{comment}{//\ must\ be\ at\ least\ 27\ bytes,\ including\ terminal\ NULL\ byte.\ \ Expected}}
\DoxyCodeLine{00600\ \textcolor{comment}{//\ type\ of\ |tp|\ is\ std::chrono::time\_point.\ \ This\ function\ returns}}
\DoxyCodeLine{00601\ \textcolor{comment}{//\ StringRef\ wrapping\ the\ buffer\ pointed\ by\ |out|,\ and\ this\ string\ is}}
\DoxyCodeLine{00602\ \textcolor{comment}{//\ terminated\ by\ NULL.}}
\DoxyCodeLine{00603\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>\ StringRef\ format\_common\_log(\textcolor{keywordtype}{char}\ *out,\ \textcolor{keyword}{const}\ T\ \&tp)\ \{}
\DoxyCodeLine{00604\ \ \ \textcolor{keyword}{auto}\ t\ =}
\DoxyCodeLine{00605\ \ \ \ \ std::chrono::duration\_cast<std::chrono::seconds>(tp.time\_since\_epoch());}
\DoxyCodeLine{00606\ \ \ \textcolor{keyword}{auto}\ p\ =\ common\_log\_date(out,\ t.count());}
\DoxyCodeLine{00607\ \ \ *p\ =\ \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{00608\ \ \ \textcolor{keywordflow}{return}\ StringRef\{out,\ p\};}
\DoxyCodeLine{00609\ \}}
\DoxyCodeLine{00610\ }
\DoxyCodeLine{00611\ \textcolor{comment}{//\ Returns\ given\ time\ |tp|\ in\ ISO\ 8601\ format\ (e.g.,}}
\DoxyCodeLine{00612\ \textcolor{comment}{//\ 2014-\/11-\/15T12:58:24.741Z\ or\ 2014-\/11-\/15T12:58:24.741+09:00).}}
\DoxyCodeLine{00613\ \textcolor{comment}{//\ Expected\ type\ of\ |tp|\ is\ std::chrono::time\_point}}
\DoxyCodeLine{00614\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>\ std::string\ format\_iso8601(\textcolor{keyword}{const}\ T\ \&tp)\ \{}
\DoxyCodeLine{00615\ \ \ \textcolor{keyword}{auto}\ t\ =\ std::chrono::duration\_cast<std::chrono::milliseconds>(}
\DoxyCodeLine{00616\ \ \ \ \ tp.time\_since\_epoch());}
\DoxyCodeLine{00617\ \ \ \textcolor{keywordflow}{return}\ iso8601\_date(t.count());}
\DoxyCodeLine{00618\ \}}
\DoxyCodeLine{00619\ }
\DoxyCodeLine{00620\ \textcolor{comment}{//\ Writes\ given\ time\ |tp|\ in\ ISO\ 8601\ format\ (e.g.,}}
\DoxyCodeLine{00621\ \textcolor{comment}{//\ 2014-\/11-\/15T12:58:24.741Z\ or\ 2014-\/11-\/15T12:58:24.741+09:00)\ in}}
\DoxyCodeLine{00622\ \textcolor{comment}{//\ buffer\ pointed\ by\ |out|.\ \ The\ buffer\ must\ be\ at\ least\ 30\ bytes,}}
\DoxyCodeLine{00623\ \textcolor{comment}{//\ including\ terminal\ NULL\ byte.\ \ Expected\ type\ of\ |tp|\ is}}
\DoxyCodeLine{00624\ \textcolor{comment}{//\ std::chrono::time\_point.\ \ This\ function\ returns\ StringRef\ wrapping}}
\DoxyCodeLine{00625\ \textcolor{comment}{//\ the\ buffer\ pointed\ by\ |out|,\ and\ this\ string\ is\ terminated\ by\ NULL.}}
\DoxyCodeLine{00626\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>\ StringRef\ format\_iso8601(\textcolor{keywordtype}{char}\ *out,\ \textcolor{keyword}{const}\ T\ \&tp)\ \{}
\DoxyCodeLine{00627\ \ \ \textcolor{keyword}{auto}\ t\ =\ std::chrono::duration\_cast<std::chrono::milliseconds>(}
\DoxyCodeLine{00628\ \ \ \ \ tp.time\_since\_epoch());}
\DoxyCodeLine{00629\ \ \ \textcolor{keyword}{auto}\ p\ =\ iso8601\_date(out,\ t.count());}
\DoxyCodeLine{00630\ \ \ *p\ =\ \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{00631\ \ \ \textcolor{keywordflow}{return}\ StringRef\{out,\ p\};}
\DoxyCodeLine{00632\ \}}
\DoxyCodeLine{00633\ }
\DoxyCodeLine{00634\ \textcolor{comment}{//\ Writes\ given\ time\ |tp|\ in\ ISO\ 8601\ basic\ format\ (e.g.,}}
\DoxyCodeLine{00635\ \textcolor{comment}{//\ 20141115T125824.741Z\ or\ 20141115T125824.741+0900)\ in\ buffer\ pointed}}
\DoxyCodeLine{00636\ \textcolor{comment}{//\ by\ |out|.\ \ The\ buffer\ must\ be\ at\ least\ 25\ bytes,\ including\ terminal}}
\DoxyCodeLine{00637\ \textcolor{comment}{//\ NULL\ byte.\ \ Expected\ type\ of\ |tp|\ is\ std::chrono::time\_point.\ \ This}}
\DoxyCodeLine{00638\ \textcolor{comment}{//\ function\ returns\ StringRef\ wrapping\ the\ buffer\ pointed\ by\ |out|,}}
\DoxyCodeLine{00639\ \textcolor{comment}{//\ and\ this\ string\ is\ terminated\ by\ NULL.}}
\DoxyCodeLine{00640\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>\ StringRef\ format\_iso8601\_basic(\textcolor{keywordtype}{char}\ *out,\ \textcolor{keyword}{const}\ T\ \&tp)\ \{}
\DoxyCodeLine{00641\ \ \ \textcolor{keyword}{auto}\ t\ =\ std::chrono::duration\_cast<std::chrono::milliseconds>(}
\DoxyCodeLine{00642\ \ \ \ \ tp.time\_since\_epoch());}
\DoxyCodeLine{00643\ \ \ \textcolor{keyword}{auto}\ p\ =\ iso8601\_basic\_date(out,\ t.count());}
\DoxyCodeLine{00644\ \ \ *p\ =\ \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{00645\ \ \ \textcolor{keywordflow}{return}\ StringRef\{out,\ p\};}
\DoxyCodeLine{00646\ \}}
\DoxyCodeLine{00647\ }
\DoxyCodeLine{00648\ \textcolor{comment}{//\ Writes\ given\ time\ |tp|\ in\ HTTP\ Date\ format\ (e.g.,\ Mon,\ 10\ Oct\ 2016}}
\DoxyCodeLine{00649\ \textcolor{comment}{//\ 10:25:58\ GMT)\ in\ buffer\ pointed\ by\ |out|.\ \ The\ buffer\ must\ be\ at}}
\DoxyCodeLine{00650\ \textcolor{comment}{//\ least\ 30\ bytes,\ including\ terminal\ NULL\ byte.\ \ Expected\ type\ of}}
\DoxyCodeLine{00651\ \textcolor{comment}{//\ |tp|\ is\ std::chrono::time\_point.\ \ This\ function\ returns\ StringRef}}
\DoxyCodeLine{00652\ \textcolor{comment}{//\ wrapping\ the\ buffer\ pointed\ by\ |out|,\ and\ this\ string\ is\ terminated}}
\DoxyCodeLine{00653\ \textcolor{comment}{//\ by\ NULL.}}
\DoxyCodeLine{00654\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>\ StringRef\ format\_http\_date(\textcolor{keywordtype}{char}\ *out,\ \textcolor{keyword}{const}\ T\ \&tp)\ \{}
\DoxyCodeLine{00655\ \ \ \textcolor{keyword}{auto}\ t\ =}
\DoxyCodeLine{00656\ \ \ \ \ std::chrono::duration\_cast<std::chrono::seconds>(tp.time\_since\_epoch());}
\DoxyCodeLine{00657\ \ \ \textcolor{keyword}{auto}\ p\ =\ http\_date(out,\ t.count());}
\DoxyCodeLine{00658\ \ \ *p\ =\ \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{00659\ \ \ \textcolor{keywordflow}{return}\ StringRef\{out,\ p\};}
\DoxyCodeLine{00660\ \}}
\DoxyCodeLine{00661\ }
\DoxyCodeLine{00662\ \textcolor{comment}{//\ Return\ the\ system\ precision\ of\ the\ template\ parameter\ |Clock|\ as}}
\DoxyCodeLine{00663\ \textcolor{comment}{//\ a\ nanosecond\ value\ of\ type\ |Rep|}}
\DoxyCodeLine{00664\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Clock,\ \textcolor{keyword}{typename}\ Rep>\ Rep\ clock\_precision()\ \{}
\DoxyCodeLine{00665\ \ \ std::chrono::duration<Rep,\ std::nano>\ duration\ =\ \textcolor{keyword}{typename}\ Clock::duration(1);}
\DoxyCodeLine{00666\ }
\DoxyCodeLine{00667\ \ \ \textcolor{keywordflow}{return}\ duration.count();}
\DoxyCodeLine{00668\ \}}
\DoxyCodeLine{00669\ }
\DoxyCodeLine{00670\ \textcolor{preprocessor}{\#ifdef\ HAVE\_LIBEV}}
\DoxyCodeLine{00671\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Duration\ =\ std::chrono::steady\_clock::duration>}
\DoxyCodeLine{00672\ Duration\ duration\_from(ev\_tstamp\ d)\ \{}
\DoxyCodeLine{00673\ \ \ \textcolor{keywordflow}{return}\ std::chrono::duration\_cast<Duration>(std::chrono::duration<double>(d));}
\DoxyCodeLine{00674\ \}}
\DoxyCodeLine{00675\ }
\DoxyCodeLine{00676\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Duration>\ ev\_tstamp\ ev\_tstamp\_from(\textcolor{keyword}{const}\ Duration\ \&d)\ \{}
\DoxyCodeLine{00677\ \ \ \textcolor{keywordflow}{return}\ std::chrono::duration<double>(d).count();}
\DoxyCodeLine{00678\ \}}
\DoxyCodeLine{00679\ \textcolor{preprocessor}{\#endif\ }\textcolor{comment}{//\ HAVE\_LIBEV}}
\DoxyCodeLine{00680\ }
\DoxyCodeLine{00681\ \textcolor{keywordtype}{int}\ make\_socket\_closeonexec(\textcolor{keywordtype}{int}\ fd);}
\DoxyCodeLine{00682\ \textcolor{keywordtype}{int}\ make\_socket\_nonblocking(\textcolor{keywordtype}{int}\ fd);}
\DoxyCodeLine{00683\ \textcolor{keywordtype}{int}\ make\_socket\_nodelay(\textcolor{keywordtype}{int}\ fd);}
\DoxyCodeLine{00684\ }
\DoxyCodeLine{00685\ \textcolor{keywordtype}{int}\ create\_nonblock\_socket(\textcolor{keywordtype}{int}\ family);}
\DoxyCodeLine{00686\ \textcolor{keywordtype}{int}\ create\_nonblock\_udp\_socket(\textcolor{keywordtype}{int}\ family);}
\DoxyCodeLine{00687\ }
\DoxyCodeLine{00688\ \textcolor{keywordtype}{int}\ bind\_any\_addr\_udp(\textcolor{keywordtype}{int}\ fd,\ \textcolor{keywordtype}{int}\ family);}
\DoxyCodeLine{00689\ }
\DoxyCodeLine{00690\ \textcolor{keywordtype}{bool}\ check\_socket\_connected(\textcolor{keywordtype}{int}\ fd);}
\DoxyCodeLine{00691\ }
\DoxyCodeLine{00692\ \textcolor{comment}{//\ Returns\ the\ error\ code\ (errno)\ by\ inspecting\ SO\_ERROR\ of\ given}}
\DoxyCodeLine{00693\ \textcolor{comment}{//\ |fd|.\ \ This\ function\ returns\ the\ error\ code\ if\ it\ succeeds,\ or\ -\/1.}}
\DoxyCodeLine{00694\ \textcolor{comment}{//\ Returning\ 0\ means\ no\ error.}}
\DoxyCodeLine{00695\ \textcolor{keywordtype}{int}\ get\_socket\_error(\textcolor{keywordtype}{int}\ fd);}
\DoxyCodeLine{00696\ }
\DoxyCodeLine{00697\ \textcolor{comment}{//\ Returns\ true\ if\ |host|\ is\ IPv6\ numeric\ address\ (e.g.,\ ::1)}}
\DoxyCodeLine{00698\ \textcolor{keywordtype}{bool}\ ipv6\_numeric\_addr(\textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ *host);}
\DoxyCodeLine{00699\ }
\DoxyCodeLine{00700\ \textcolor{comment}{//\ Parses\ |s|\ as\ unsigned\ integer\ and\ returns\ the\ parsed\ integer.}}
\DoxyCodeLine{00701\ \textcolor{comment}{//\ Additionally,\ if\ |s|\ ends\ with\ 'k',\ 'm',\ 'g'\ and\ its\ upper\ case}}
\DoxyCodeLine{00702\ \textcolor{comment}{//\ characters,\ multiply\ the\ integer\ by\ 1024,\ 1024\ *\ 1024\ and\ 1024\ *}}
\DoxyCodeLine{00703\ \textcolor{comment}{//\ 1024\ respectively.\ \ If\ there\ is\ an\ error,\ returns\ no\ value.}}
\DoxyCodeLine{00704\ std::optional<int64\_t>\ parse\_uint\_with\_unit(\textcolor{keyword}{const}\ StringRef\ \&s);}
\DoxyCodeLine{00705\ }
\DoxyCodeLine{00706\ \textcolor{comment}{//\ Parses\ |s|\ as\ unsigned\ integer\ and\ returns\ the\ parsed\ integer..}}
\DoxyCodeLine{00707\ std::optional<int64\_t>\ parse\_uint(\textcolor{keyword}{const}\ StringRef\ \&s);}
\DoxyCodeLine{00708\ }
\DoxyCodeLine{00709\ \textcolor{comment}{//\ Parses\ |s|\ as\ unsigned\ integer\ and\ returns\ the\ parsed\ integer}}
\DoxyCodeLine{00710\ \textcolor{comment}{//\ casted\ to\ double.\ \ If\ |s|\ ends\ with\ "{}s"{},\ the\ parsed\ value's\ unit\ is}}
\DoxyCodeLine{00711\ \textcolor{comment}{//\ a\ second.\ \ If\ |s|\ ends\ with\ "{}ms"{},\ the\ unit\ is\ millisecond.}}
\DoxyCodeLine{00712\ \textcolor{comment}{//\ Similarly,\ it\ also\ supports\ 'm'\ and\ 'h'\ for\ minutes\ and\ hours}}
\DoxyCodeLine{00713\ \textcolor{comment}{//\ respectively.\ \ If\ none\ of\ them\ are\ given,\ the\ unit\ is\ second.\ \ This}}
\DoxyCodeLine{00714\ \textcolor{comment}{//\ function\ returns\ no\ value\ if\ error\ occurs.}}
\DoxyCodeLine{00715\ std::optional<double>\ parse\_duration\_with\_unit(\textcolor{keyword}{const}\ StringRef\ \&s);}
\DoxyCodeLine{00716\ }
\DoxyCodeLine{00717\ \textcolor{comment}{//\ Returns\ string\ representation\ of\ time\ duration\ |t|.\ \ If\ t\ has}}
\DoxyCodeLine{00718\ \textcolor{comment}{//\ fractional\ part\ (at\ least\ more\ than\ or\ equal\ to\ 1e-\/3),\ |t|\ is}}
\DoxyCodeLine{00719\ \textcolor{comment}{//\ multiplied\ by\ 1000\ and\ the\ unit\ "{}ms"{}\ is\ appended.\ \ Otherwise,\ |t|}}
\DoxyCodeLine{00720\ \textcolor{comment}{//\ is\ left\ as\ is\ and\ "{}s"{}\ is\ appended.}}
\DoxyCodeLine{00721\ std::string\ duration\_str(\textcolor{keywordtype}{double}\ t);}
\DoxyCodeLine{00722\ }
\DoxyCodeLine{00723\ \textcolor{comment}{//\ Returns\ string\ representation\ of\ time\ duration\ |t|.\ \ It\ appends}}
\DoxyCodeLine{00724\ \textcolor{comment}{//\ unit\ after\ the\ formatting.\ \ The\ available\ units\ are\ s,\ ms\ and\ us.}}
\DoxyCodeLine{00725\ \textcolor{comment}{//\ The\ unit\ which\ is\ equal\ to\ or\ less\ than\ |t|\ is\ used\ and\ 2}}
\DoxyCodeLine{00726\ \textcolor{comment}{//\ fractional\ digits\ follow.}}
\DoxyCodeLine{00727\ std::string\ format\_duration(\textcolor{keyword}{const}\ std::chrono::microseconds\ \&u);}
\DoxyCodeLine{00728\ }
\DoxyCodeLine{00729\ \textcolor{comment}{//\ Just\ like\ above,\ but\ this\ takes\ |t|\ as\ seconds.}}
\DoxyCodeLine{00730\ std::string\ format\_duration(\textcolor{keywordtype}{double}\ t);}
\DoxyCodeLine{00731\ }
\DoxyCodeLine{00732\ \textcolor{comment}{//\ The\ maximum\ buffer\ size\ including\ terminal\ NULL\ to\ store\ the\ result}}
\DoxyCodeLine{00733\ \textcolor{comment}{//\ of\ make\_hostport.}}
\DoxyCodeLine{00734\ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{size\_t}\ max\_hostport\ =\ NI\_MAXHOST\ +\ \textcolor{comment}{/*\ []\ for\ IPv6\ */}\ 2\ +\ \textcolor{comment}{/*\ :\ */}\ 1\ +}
\DoxyCodeLine{00735\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{/*\ port\ */}\ 5\ +\ \textcolor{comment}{/*\ terminal\ NULL\ */}\ 1;}
\DoxyCodeLine{00736\ }
\DoxyCodeLine{00737\ \textcolor{comment}{//\ Just\ like\ make\_http\_hostport(),\ but\ doesn't\ treat\ 80\ and\ 443}}
\DoxyCodeLine{00738\ \textcolor{comment}{//\ specially.}}
\DoxyCodeLine{00739\ StringRef\ make\_hostport(BlockAllocator\ \&balloc,\ \textcolor{keyword}{const}\ StringRef\ \&host,}
\DoxyCodeLine{00740\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ uint16\_t\ port);}
\DoxyCodeLine{00741\ }
\DoxyCodeLine{00742\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ OutputIt>}
\DoxyCodeLine{00743\ StringRef\ make\_hostport(OutputIt\ first,\ \textcolor{keyword}{const}\ StringRef\ \&host,\ uint16\_t\ port)\ \{}
\DoxyCodeLine{00744\ \ \ \textcolor{keyword}{auto}\ ipv6\ =\ ipv6\_numeric\_addr(host.data());}
\DoxyCodeLine{00745\ \ \ \textcolor{keyword}{auto}\ serv\ =\ utos(port);}
\DoxyCodeLine{00746\ \ \ \textcolor{keyword}{auto}\ p\ =\ first;}
\DoxyCodeLine{00747\ }
\DoxyCodeLine{00748\ \ \ \textcolor{keywordflow}{if}\ (ipv6)\ \{}
\DoxyCodeLine{00749\ \ \ \ \ *p++\ =\ \textcolor{charliteral}{'['};}
\DoxyCodeLine{00750\ \ \ \}}
\DoxyCodeLine{00751\ }
\DoxyCodeLine{00752\ \ \ p\ =\ std::copy(std::begin(host),\ std::end(host),\ p);}
\DoxyCodeLine{00753\ }
\DoxyCodeLine{00754\ \ \ \textcolor{keywordflow}{if}\ (ipv6)\ \{}
\DoxyCodeLine{00755\ \ \ \ \ *p++\ =\ \textcolor{charliteral}{']'};}
\DoxyCodeLine{00756\ \ \ \}}
\DoxyCodeLine{00757\ }
\DoxyCodeLine{00758\ \ \ *p++\ =\ \textcolor{charliteral}{':'};}
\DoxyCodeLine{00759\ }
\DoxyCodeLine{00760\ \ \ p\ =\ std::copy(std::begin(serv),\ std::end(serv),\ p);}
\DoxyCodeLine{00761\ }
\DoxyCodeLine{00762\ \ \ *p\ =\ \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{00763\ }
\DoxyCodeLine{00764\ \ \ \textcolor{keywordflow}{return}\ StringRef\{std::span\{first,\ p\}\};}
\DoxyCodeLine{00765\ \}}
\DoxyCodeLine{00766\ }
\DoxyCodeLine{00767\ \textcolor{comment}{//\ Creates\ "{}host:port"{}\ string\ using\ given\ |host|\ and\ |port|.\ \ If}}
\DoxyCodeLine{00768\ \textcolor{comment}{//\ |host|\ is\ numeric\ IPv6\ address\ (e.g.,\ ::1),\ it\ is\ enclosed\ by\ "{}["{}}}
\DoxyCodeLine{00769\ \textcolor{comment}{//\ and\ "{}]"{}.\ \ If\ |port|\ is\ 80\ or\ 443,\ port\ part\ is\ omitted.}}
\DoxyCodeLine{00770\ StringRef\ make\_http\_hostport(BlockAllocator\ \&balloc,\ \textcolor{keyword}{const}\ StringRef\ \&host,}
\DoxyCodeLine{00771\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ uint16\_t\ port);}
\DoxyCodeLine{00772\ }
\DoxyCodeLine{00773\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ OutputIt>}
\DoxyCodeLine{00774\ StringRef\ make\_http\_hostport(OutputIt\ first,\ \textcolor{keyword}{const}\ StringRef\ \&host,}
\DoxyCodeLine{00775\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ uint16\_t\ port)\ \{}
\DoxyCodeLine{00776\ \ \ \textcolor{keywordflow}{if}\ (port\ !=\ 80\ \&\&\ port\ !=\ 443)\ \{}
\DoxyCodeLine{00777\ \ \ \ \ \textcolor{keywordflow}{return}\ make\_hostport(first,\ host,\ port);}
\DoxyCodeLine{00778\ \ \ \}}
\DoxyCodeLine{00779\ }
\DoxyCodeLine{00780\ \ \ \textcolor{keyword}{auto}\ ipv6\ =\ ipv6\_numeric\_addr(host.data());}
\DoxyCodeLine{00781\ \ \ \textcolor{keyword}{auto}\ p\ =\ first;}
\DoxyCodeLine{00782\ }
\DoxyCodeLine{00783\ \ \ \textcolor{keywordflow}{if}\ (ipv6)\ \{}
\DoxyCodeLine{00784\ \ \ \ \ *p++\ =\ \textcolor{charliteral}{'['};}
\DoxyCodeLine{00785\ \ \ \}}
\DoxyCodeLine{00786\ }
\DoxyCodeLine{00787\ \ \ p\ =\ std::copy(std::begin(host),\ std::end(host),\ p);}
\DoxyCodeLine{00788\ }
\DoxyCodeLine{00789\ \ \ \textcolor{keywordflow}{if}\ (ipv6)\ \{}
\DoxyCodeLine{00790\ \ \ \ \ *p++\ =\ \textcolor{charliteral}{']'};}
\DoxyCodeLine{00791\ \ \ \}}
\DoxyCodeLine{00792\ }
\DoxyCodeLine{00793\ \ \ *p\ =\ \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{00794\ }
\DoxyCodeLine{00795\ \ \ \textcolor{keywordflow}{return}\ StringRef\{std::span\{first,\ p\}\};}
\DoxyCodeLine{00796\ \}}
\DoxyCodeLine{00797\ }
\DoxyCodeLine{00798\ \textcolor{comment}{//\ hexdump\ dumps\ |data|\ of\ length\ |datalen|\ in\ the\ format\ similar\ to}}
\DoxyCodeLine{00799\ \textcolor{comment}{//\ hexdump(1)\ with\ -\/C\ option.\ \ This\ function\ returns\ 0\ if\ it\ succeeds,}}
\DoxyCodeLine{00800\ \textcolor{comment}{//\ or\ -\/1.}}
\DoxyCodeLine{00801\ \textcolor{keywordtype}{int}\ hexdump(FILE\ *out,\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{void}\ *data,\ \textcolor{keywordtype}{size\_t}\ datalen);}
\DoxyCodeLine{00802\ }
\DoxyCodeLine{00803\ \textcolor{comment}{//\ Copies\ 2\ byte\ unsigned\ integer\ |n|\ in\ host\ byte\ order\ to\ |buf|\ in}}
\DoxyCodeLine{00804\ \textcolor{comment}{//\ network\ byte\ order.}}
\DoxyCodeLine{00805\ \textcolor{keywordtype}{void}\ put\_uint16be(uint8\_t\ *buf,\ uint16\_t\ n);}
\DoxyCodeLine{00806\ }
\DoxyCodeLine{00807\ \textcolor{comment}{//\ Copies\ 4\ byte\ unsigned\ integer\ |n|\ in\ host\ byte\ order\ to\ |buf|\ in}}
\DoxyCodeLine{00808\ \textcolor{comment}{//\ network\ byte\ order.}}
\DoxyCodeLine{00809\ \textcolor{keywordtype}{void}\ put\_uint32be(uint8\_t\ *buf,\ uint32\_t\ n);}
\DoxyCodeLine{00810\ }
\DoxyCodeLine{00811\ \textcolor{comment}{//\ Retrieves\ 2\ byte\ unsigned\ integer\ stored\ in\ |data|\ in\ network\ byte}}
\DoxyCodeLine{00812\ \textcolor{comment}{//\ order\ and\ returns\ it\ in\ host\ byte\ order.}}
\DoxyCodeLine{00813\ uint16\_t\ get\_uint16(\textcolor{keyword}{const}\ uint8\_t\ *data);}
\DoxyCodeLine{00814\ }
\DoxyCodeLine{00815\ \textcolor{comment}{//\ Retrieves\ 4\ byte\ unsigned\ integer\ stored\ in\ |data|\ in\ network\ byte}}
\DoxyCodeLine{00816\ \textcolor{comment}{//\ order\ and\ returns\ it\ in\ host\ byte\ order.}}
\DoxyCodeLine{00817\ uint32\_t\ get\_uint32(\textcolor{keyword}{const}\ uint8\_t\ *data);}
\DoxyCodeLine{00818\ }
\DoxyCodeLine{00819\ \textcolor{comment}{//\ Retrieves\ 8\ byte\ unsigned\ integer\ stored\ in\ |data|\ in\ network\ byte}}
\DoxyCodeLine{00820\ \textcolor{comment}{//\ order\ and\ returns\ it\ in\ host\ byte\ order.}}
\DoxyCodeLine{00821\ uint64\_t\ get\_uint64(\textcolor{keyword}{const}\ uint8\_t\ *data);}
\DoxyCodeLine{00822\ }
\DoxyCodeLine{00823\ \textcolor{comment}{//\ Reads\ mime\ types\ file\ (see\ /etc/mime.types),\ and\ stores\ extension}}
\DoxyCodeLine{00824\ \textcolor{comment}{//\ -\/>\ MIME\ type\ map\ in\ |res|.\ \ This\ function\ returns\ 0\ if\ it\ succeeds,}}
\DoxyCodeLine{00825\ \textcolor{comment}{//\ or\ -\/1.}}
\DoxyCodeLine{00826\ \textcolor{keywordtype}{int}\ read\_mime\_types(std::map<std::string,\ std::string>\ \&res,}
\DoxyCodeLine{00827\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ *filename);}
\DoxyCodeLine{00828\ }
\DoxyCodeLine{00829\ \textcolor{comment}{//\ Fills\ random\ alpha\ and\ digit\ byte\ to\ the\ range\ [|first|,\ |last|).}}
\DoxyCodeLine{00830\ \textcolor{comment}{//\ Returns\ the\ one\ beyond\ the\ |last|.}}
\DoxyCodeLine{00831\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ OutputIt,\ \textcolor{keyword}{typename}\ Generator>}
\DoxyCodeLine{00832\ OutputIt\ random\_alpha\_digit(OutputIt\ first,\ OutputIt\ last,\ Generator\ \&gen)\ \{}
\DoxyCodeLine{00833\ \ \ \textcolor{comment}{//\ If\ we\ use\ uint8\_t\ instead\ char,\ gcc\ 6.2.0\ complains\ by\ shouting}}
\DoxyCodeLine{00834\ \ \ \textcolor{comment}{//\ char-\/array\ initialized\ from\ wide\ string.}}
\DoxyCodeLine{00835\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{char}\ s[]\ =}
\DoxyCodeLine{00836\ \ \ \ \ \textcolor{stringliteral}{"{}ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"{}};}
\DoxyCodeLine{00837\ \ \ std::uniform\_int\_distribution<>\ dis(0,\ 26\ *\ 2\ +\ 10\ -\/\ 1);}
\DoxyCodeLine{00838\ \ \ \textcolor{keywordflow}{for}\ (;\ first\ !=\ last;\ ++first)\ \{}
\DoxyCodeLine{00839\ \ \ \ \ *first\ =\ s[dis(gen)];}
\DoxyCodeLine{00840\ \ \ \}}
\DoxyCodeLine{00841\ \ \ \textcolor{keywordflow}{return}\ first;}
\DoxyCodeLine{00842\ \}}
\DoxyCodeLine{00843\ }
\DoxyCodeLine{00844\ \textcolor{comment}{//\ Fills\ random\ bytes\ to\ the\ range\ [|first|,\ |last|).}}
\DoxyCodeLine{00845\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ OutputIt,\ \textcolor{keyword}{typename}\ Generator>}
\DoxyCodeLine{00846\ \textcolor{keywordtype}{void}\ random\_bytes(OutputIt\ first,\ OutputIt\ last,\ Generator\ \&gen)\ \{}
\DoxyCodeLine{00847\ \ \ std::uniform\_int\_distribution<uint8\_t>\ dis;}
\DoxyCodeLine{00848\ \ \ std::generate(first,\ last,\ [\&dis,\ \&gen]()\ \{\ \textcolor{keywordflow}{return}\ dis(gen);\ \});}
\DoxyCodeLine{00849\ \}}
\DoxyCodeLine{00850\ }
\DoxyCodeLine{00851\ \textcolor{comment}{//\ Shuffles\ the\ range\ [|first|,\ |last|]\ by\ calling\ swap\ function\ |fun|}}
\DoxyCodeLine{00852\ \textcolor{comment}{//\ for\ each\ pair.\ \ |fun|\ takes\ 2\ RandomIt\ iterators.\ \ If\ |fun|\ is}}
\DoxyCodeLine{00853\ \textcolor{comment}{//\ noop,\ no\ modification\ is\ made.}}
\DoxyCodeLine{00854\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ RandomIt,\ \textcolor{keyword}{typename}\ Generator,\ \textcolor{keyword}{typename}\ SwapFun>}
\DoxyCodeLine{00855\ \textcolor{keywordtype}{void}\ shuffle(RandomIt\ first,\ RandomIt\ last,\ Generator\ \&\&gen,\ SwapFun\ fun)\ \{}
\DoxyCodeLine{00856\ \ \ \textcolor{keyword}{auto}\ len\ =\ std::distance(first,\ last);}
\DoxyCodeLine{00857\ \ \ \textcolor{keywordflow}{if}\ (len\ <\ 2)\ \{}
\DoxyCodeLine{00858\ \ \ \ \ \textcolor{keywordflow}{return};}
\DoxyCodeLine{00859\ \ \ \}}
\DoxyCodeLine{00860\ }
\DoxyCodeLine{00861\ \ \ \textcolor{keyword}{using\ }dist\_type\ =\ std::uniform\_int\_distribution<size\_t>;}
\DoxyCodeLine{00862\ \ \ \textcolor{keyword}{using\ }param\_type\ =\ dist\_type::param\_type;}
\DoxyCodeLine{00863\ }
\DoxyCodeLine{00864\ \ \ dist\_type\ d;}
\DoxyCodeLine{00865\ }
\DoxyCodeLine{00866\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{decltype}(len)\ i\ =\ 0;\ i\ <\ len\ -\/\ 1;\ ++i)\ \{}
\DoxyCodeLine{00867\ \ \ \ \ fun(first\ +\ i,\ first\ +\ d(gen,\ param\_type(i,\ len\ -\/\ 1)));}
\DoxyCodeLine{00868\ \ \ \}}
\DoxyCodeLine{00869\ \}}
\DoxyCodeLine{00870\ }
\DoxyCodeLine{00871\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ OutputIterator,\ \textcolor{keyword}{typename}\ CharT,\ \textcolor{keywordtype}{size\_t}\ N>}
\DoxyCodeLine{00872\ OutputIterator\ copy\_lit(OutputIterator\ it,\ CharT\ (\&s)[N])\ \{}
\DoxyCodeLine{00873\ \ \ \textcolor{keywordflow}{return}\ std::copy\_n(s,\ N\ -\/\ 1,\ it);}
\DoxyCodeLine{00874\ \}}
\DoxyCodeLine{00875\ }
\DoxyCodeLine{00876\ \textcolor{comment}{//\ Returns\ x**y}}
\DoxyCodeLine{00877\ \textcolor{keywordtype}{double}\ int\_pow(\textcolor{keywordtype}{double}\ x,\ \textcolor{keywordtype}{size\_t}\ y);}
\DoxyCodeLine{00878\ }
\DoxyCodeLine{00879\ uint32\_t\ hash32(\textcolor{keyword}{const}\ StringRef\ \&s);}
\DoxyCodeLine{00880\ }
\DoxyCodeLine{00881\ \textcolor{comment}{//\ Computes\ SHA-\/256\ of\ |s|,\ and\ stores\ it\ in\ |buf|.\ \ This\ function}}
\DoxyCodeLine{00882\ \textcolor{comment}{//\ returns\ 0\ if\ it\ succeeds,\ or\ -\/1.}}
\DoxyCodeLine{00883\ \textcolor{keywordtype}{int}\ sha256(uint8\_t\ *buf,\ \textcolor{keyword}{const}\ StringRef\ \&s);}
\DoxyCodeLine{00884\ }
\DoxyCodeLine{00885\ \textcolor{comment}{//\ Computes\ SHA-\/1\ of\ |s|,\ and\ stores\ it\ in\ |buf|.\ \ This\ function}}
\DoxyCodeLine{00886\ \textcolor{comment}{//\ returns\ 0\ if\ it\ succeeds,\ or\ -\/1.}}
\DoxyCodeLine{00887\ \textcolor{keywordtype}{int}\ sha1(uint8\_t\ *buf,\ \textcolor{keyword}{const}\ StringRef\ \&s);}
\DoxyCodeLine{00888\ }
\DoxyCodeLine{00889\ \textcolor{comment}{//\ Returns\ host\ from\ |hostport|.\ \ If\ host\ cannot\ be\ found\ in}}
\DoxyCodeLine{00890\ \textcolor{comment}{//\ |hostport|,\ returns\ empty\ string.\ \ The\ returned\ string\ might\ not\ be}}
\DoxyCodeLine{00891\ \textcolor{comment}{//\ NULL-\/terminated.}}
\DoxyCodeLine{00892\ StringRef\ extract\_host(\textcolor{keyword}{const}\ StringRef\ \&hostport);}
\DoxyCodeLine{00893\ }
\DoxyCodeLine{00894\ \textcolor{comment}{//\ split\_hostport\ splits\ host\ and\ port\ in\ |hostport|.\ \ Unlike}}
\DoxyCodeLine{00895\ \textcolor{comment}{//\ extract\_host,\ square\ brackets\ enclosing\ host\ name\ is\ stripped.\ \ If}}
\DoxyCodeLine{00896\ \textcolor{comment}{//\ port\ is\ not\ available,\ it\ returns\ empty\ string\ in\ the\ second}}
\DoxyCodeLine{00897\ \textcolor{comment}{//\ string.\ \ The\ returned\ string\ might\ not\ be\ NULL-\/terminated.\ \ On\ any}}
\DoxyCodeLine{00898\ \textcolor{comment}{//\ error,\ it\ returns\ a\ pair\ which\ has\ empty\ strings.}}
\DoxyCodeLine{00899\ std::pair<StringRef,\ StringRef>\ split\_hostport(\textcolor{keyword}{const}\ StringRef\ \&hostport);}
\DoxyCodeLine{00900\ }
\DoxyCodeLine{00901\ \textcolor{comment}{//\ Returns\ new\ std::mt19937\ object.}}
\DoxyCodeLine{00902\ std::mt19937\ make\_mt19937();}
\DoxyCodeLine{00903\ }
\DoxyCodeLine{00904\ \textcolor{comment}{//\ daemonize\ calls\ daemon(3).\ \ If\ \_\_APPLE\_\_\ is\ defined,\ it\ implements}}
\DoxyCodeLine{00905\ \textcolor{comment}{//\ daemon()\ using\ fork().}}
\DoxyCodeLine{00906\ \textcolor{keywordtype}{int}\ daemonize(\textcolor{keywordtype}{int}\ nochdir,\ \textcolor{keywordtype}{int}\ noclose);}
\DoxyCodeLine{00907\ }
\DoxyCodeLine{00908\ \textcolor{comment}{//\ Returns\ |s|\ from\ which\ trailing\ white\ spaces\ (SPC\ or\ HTAB)\ are}}
\DoxyCodeLine{00909\ \textcolor{comment}{//\ removed.\ \ If\ any\ white\ spaces\ are\ removed,\ new\ string\ is\ allocated}}
\DoxyCodeLine{00910\ \textcolor{comment}{//\ by\ |balloc|\ and\ returned.\ \ Otherwise,\ the\ copy\ of\ |s|\ is\ returned}}
\DoxyCodeLine{00911\ \textcolor{comment}{//\ without\ allocation.}}
\DoxyCodeLine{00912\ StringRef\ rstrip(BlockAllocator\ \&balloc,\ \textcolor{keyword}{const}\ StringRef\ \&s);}
\DoxyCodeLine{00913\ }
\DoxyCodeLine{00914\ \textcolor{preprocessor}{\#ifdef\ ENABLE\_HTTP3}}
\DoxyCodeLine{00915\ \textcolor{keywordtype}{int}\ msghdr\_get\_local\_addr(Address\ \&dest,\ msghdr\ *msg,\ \textcolor{keywordtype}{int}\ family);}
\DoxyCodeLine{00916\ }
\DoxyCodeLine{00917\ uint8\_t\ msghdr\_get\_ecn(msghdr\ *msg,\ \textcolor{keywordtype}{int}\ family);}
\DoxyCodeLine{00918\ }
\DoxyCodeLine{00919\ \textcolor{comment}{//\ msghdr\_get\_udp\_gro\ returns\ UDP\_GRO\ value\ from\ |msg|.\ \ If\ UDP\_GRO\ is}}
\DoxyCodeLine{00920\ \textcolor{comment}{//\ not\ found,\ or\ UDP\_GRO\ is\ not\ supported,\ this\ function\ returns\ 0.}}
\DoxyCodeLine{00921\ \textcolor{keywordtype}{size\_t}\ msghdr\_get\_udp\_gro(msghdr\ *msg);}
\DoxyCodeLine{00922\ \textcolor{preprocessor}{\#endif\ }\textcolor{comment}{//\ ENABLE\_HTTP3}}
\DoxyCodeLine{00923\ }
\DoxyCodeLine{00924\ \}\ \textcolor{comment}{//\ namespace\ util}}
\DoxyCodeLine{00925\ }
\DoxyCodeLine{00926\ \}\ \textcolor{comment}{//\ namespace\ nghttp2}}
\DoxyCodeLine{00927\ }
\DoxyCodeLine{00928\ \textcolor{preprocessor}{\#endif\ }\textcolor{comment}{//\ UTIL\_H}}

\end{DoxyCode}
