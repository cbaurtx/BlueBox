\doxysection{managed\+\_\+components/espressif\+\_\+\+\_\+esp-\/dsp/modules/kalman/ekf\+\_\+imu13states/docs Directory Reference}
\hypertarget{dir_3b9771c313cff84cbeca1d4d406a7345}{}\label{dir_3b9771c313cff84cbeca1d4d406a7345}\index{managed\_components/espressif\_\_esp-\/dsp/modules/kalman/ekf\_imu13states/docs Directory Reference@{managed\_components/espressif\_\_esp-\/dsp/modules/kalman/ekf\_imu13states/docs Directory Reference}}
Directory dependency graph for docs\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=184pt]{dir_3b9771c313cff84cbeca1d4d406a7345_dep}
\end{center}
\end{figure}


\doxysubsection{Detailed Description}
\hypertarget{dir_3b9771c313cff84cbeca1d4d406a7345_autotoc_md189}{}\doxysubsection{\texorpdfstring{Extended Kalman Filter for IMU sensor with 13 calculated states}{Extended Kalman Filter for IMU sensor with 13 calculated states}}\label{dir_3b9771c313cff84cbeca1d4d406a7345_autotoc_md189}
The extended Kalman filter (EKF) with 13 states designed to be used with data from common IMU sensor, like MPU9250 or MPU6050. These sensors provide gyroscope, accelerometer and magnetometer data. The sensors have measurement errors, and it\textquotesingle{}s not possible to use them for calculation system attitude. For that the EKF should be used. Current implementation of EKF calculates 13 value to define the system state\+:
\begin{DoxyEnumerate}
\item System attitude \mbox{[}0..3\mbox{]}\+: quaternion that describes absolute value of system attitude (w, x,y,z)
\item Gyroscope sensor errors\mbox{[}4..6\mbox{]}\+: bias values (x,y,z)
\item Magnetometer vector value\mbox{[}7..9\mbox{]}\+: absolute value of magnetometer sensor (x,y,z)
\item Magnetometer vector offset\mbox{[}10..12\mbox{]}\+: absolute value of magnetometer sensor offset (x,y,z) These values calculated by the EKF and stored to the X vector. Magnetometer value from the sensor has some value and offset. This information needed to calculate system attitude. Magnetometer sensor value = R\texorpdfstring{$\ast$}{*}\+Magn\+\_\+\+Amplitude + Magn\+\_\+offset. Where R -\/ rotation matrix from system attitude, Magn\+\_\+\+Amplitude -\/ real magnetometer value calculated by the EKF Magn\+\_\+offset -\/ magnetometer offset value (called deviation)
\end{DoxyEnumerate}\hypertarget{dir_3b9771c313cff84cbeca1d4d406a7345_autotoc_md190}{}\doxysubsection{\texorpdfstring{How to use EKF}{How to use EKF}}\label{dir_3b9771c313cff84cbeca1d4d406a7345_autotoc_md190}
The EKF has two main methods\+: state calculation (Process(...)) and state correction (Update\+Ref\+Measurement() in our case). The current EKF has one main input value -\/ is a gyroscope (gyro) angular speed. If the gyro has no bias error, then it\textquotesingle{}s enough to call Process(...) method, and EKF will calculate system attitude. But, the gyro has a bias error and that\textquotesingle{}s why, the Update\+Ref\+Measurement(...) must be called, when reference accelerometer and magnetometer values are available. After the firs start, the EKF will need some time to calculate correct gyro bias and magnetometer deviation. This is a calibration phase. To avoid this phase every time after filter started, it\textquotesingle{}s better to store X vector and P matrix to the non-\/volatile memory, and restore them after system started. The sequence in this case will be\+: Init()-\/\texorpdfstring{$>$}{>} restore X and P values (if exist) -\/\texorpdfstring{$>$}{>} go to normal process\hypertarget{dir_3b9771c313cff84cbeca1d4d406a7345_autotoc_md191}{}\doxysubsection{\texorpdfstring{Adjustable parameters}{Adjustable parameters}}\label{dir_3b9771c313cff84cbeca1d4d406a7345_autotoc_md191}
There two lists of parameters that could be adjusted\+: R -\/ measurement noise covariance values, and Q -\/ model noise matrix. The R is an array with values for diagonal matrix. Then smaller value R for reference value, then more EKF will trust for this value. In normal case, the R values should be between 0.\+001 and 1. The Q -\/ is a diagonal (only values in main diagonal are important) noise matrix of state vector. This matrix define how good value in state vector X should be. 