\chapter{How to use {\ttfamily mrb\+\_\+gc\+\_\+arena\+\_\+save()}/{\ttfamily mrb\+\_\+gc\+\_\+arena\+\_\+restore()}/{\ttfamily mrb\+\_\+gc\+\_\+protect()} }
\hypertarget{md_managed__components_2espressif____nghttp_2nghttp2_2third-party_2mruby_2doc_2guides_2gc-arena-howto}{}\label{md_managed__components_2espressif____nghttp_2nghttp2_2third-party_2mruby_2doc_2guides_2gc-arena-howto}\index{How to use $<$tt$>$mrb\_gc\_arena\_save()$<$/tt$>$/$<$tt$>$mrb\_gc\_arena\_restore()$<$/tt$>$/$<$tt$>$mrb\_gc\_protect()$<$/tt$>$@{How to use $<$tt$>$mrb\_gc\_arena\_save()$<$/tt$>$/$<$tt$>$mrb\_gc\_arena\_restore()$<$/tt$>$/$<$tt$>$mrb\_gc\_protect()$<$/tt$>$}}
\label{md_managed__components_2espressif____nghttp_2nghttp2_2third-party_2mruby_2doc_2guides_2gc-arena-howto_autotoc_md336}%
\Hypertarget{md_managed__components_2espressif____nghttp_2nghttp2_2third-party_2mruby_2doc_2guides_2gc-arena-howto_autotoc_md336}%


{\itshape This is an English translation of \href{https://www.rubyist.net/~matz/20130731.html}{\texttt{Matz\textquotesingle{}s blog post}} written in Japanese.} {\itshape Some parts are updated to reflect recent changes.}

When you are extending mruby using C language, you may encounter mysterious "{}arena overflow error"{} or memory leak or very slow execution speed. This is an error indicating overflow of "{}\+GC arena"{} implementing "{}conservative GC"{}.

GC (garbage collector) must ensure that object is "{}alive"{}, in other words, that it is referenced by somewhere from the program. This can be determined by checking if the object can be directly or indirectly referenced by root. The local variables, global variables and constants etc. are root.

If program execution is performed inside mruby VM, there is nothing to worry about because GC can access all roots owned by the VM.

The problem arises when executing C functions. The object referenced by C variable is also "{}alive"{}, but mruby GC cannot aware of this, so it might mistakenly recognize the objects referenced by only C variables as dead.

This can be a fatal bug if the GC tries to collect a live object.

In CRuby, we scan C stack area, and use C variable as root to check whether object is alive or not. Of course, because we are accessing C stack just as memory region, we never know it is an integer or a pointer. We work around this by assuming that if it looks like a pointer, then assume it as a pointer. We call it "{}conservative"{}.

By the way, CRuby\textquotesingle{}s "{}conservative GC"{} has some problems.

The biggest problem is we have no way to access to the stack area in portable way. Therefore, we cannot use this method if we\textquotesingle{}d like to implement highly portable runtime, like mruby.

So we came up with another plan to implement "{}conservative GC"{} in mruby.

Again, the problem is when an object which was created in C function, becomes no longer referenced in the Ruby world, and cannot be treated as garbage.

In mruby, we recognize all objects created in C function are alive. Then we have no problem such as confusing a live object as dead.

This means that because we cannot collect a truly dead object, we may lose efficiency, but as a trade-\/off the GC itself is highly portable. We can say goodbye to the problem that GC deletes live objects due to optimization which sometimes occurs in CRuby.

According to this idea, we have a table, called "{}\+GC arena"{}, which remembers objects created in C function.

The arena is stack structure, when C function execution is returned to mruby VM, all objects registered in the arena are popped.

This works very well, but can cause another problem\+: "{}arena overflow error"{} or memory leak.

As of this writing, mruby automatically extend arena to remember objects (See {\ttfamily MRB\+\_\+\+GC\+\_\+\+FIXED\+\_\+\+ARENA} and {\ttfamily MRB\+\_\+\+GC\+\_\+\+ARENA\+\_\+\+SIZE} in \doxysectlink{md_managed__components_2espressif____nghttp_2nghttp2_2third-party_2mruby_2doc_2guides_2mrbconf}{doc/guides/mrbconf.md}{0}).

If you create many objects in C functions, memory usage will increase, since GC never kicks in. This memory usage may look like memory leaks, but will also make execution slower as more memory will need to be allocated.

With the build time configuration, you can limit the maximum size of arena (e.\+g., 100). Then if you create many objects, arena overflows, thus you will get an "{}arena overflow error"{}.

To work around these problems, we have {\ttfamily mrb\+\_\+gc\+\_\+arena\+\_\+save()} and {\ttfamily mrb\+\_\+gc\+\_\+arena\+\_\+restore()} functions.

{\ttfamily int mrb\+\_\+gc\+\_\+arena\+\_\+save(mrb)} returns the current position of the stack top of GC arena, and {\ttfamily void mrb\+\_\+gc\+\_\+arena\+\_\+restore(mrb, idx)} sets the stack top position to back to given {\ttfamily idx}.

We can use them like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ arena\_idx\ =\ mrb\_gc\_arena\_save(mrb);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ ...create\ objects...}}
\DoxyCodeLine{mrb\_gc\_arena\_restore(mrb,\ arena\_idx);}

\end{DoxyCode}


In mruby, C function calls are surrounded by this save/restore, but we can further optimize memory usage by surrounding save/restore, and can avoid creating arena overflow bugs.

Let\textquotesingle{}s take a real example. Here is the source code of {\ttfamily Array\#inspect}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{static}\ \mbox{\hyperlink{structmrb__value}{mrb\_value}}}
\DoxyCodeLine{inspect\_ary(\mbox{\hyperlink{structmrb__state}{mrb\_state}}\ *mrb,\ \mbox{\hyperlink{structmrb__value}{mrb\_value}}\ ary,\ \mbox{\hyperlink{structmrb__value}{mrb\_value}}\ list)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ mrb\_int\ i;}
\DoxyCodeLine{\ \ \mbox{\hyperlink{structmrb__value}{mrb\_value}}\ s,\ arystr;}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{char}\ head[]\ =\ \{\ \textcolor{charliteral}{'['}\ \};}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{char}\ sep[]\ =\ \{\ \textcolor{charliteral}{','},\ \textcolor{charliteral}{'\ '}\ \};}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{char}\ tail[]\ =\ \{\ \textcolor{charliteral}{']'}\ \};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{comment}{/*\ check\ recursive\ */}}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{for}\ (i=0;\ i<RARRAY\_LEN(list);\ i++)\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{if}\ (mrb\_obj\_equal(mrb,\ ary,\ RARRAY\_PTR(list)[i]))\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keywordflow}{return}\ mrb\_str\_new(mrb,\ \textcolor{stringliteral}{"{}[...]"{}},\ 5);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ mrb\_ary\_push(mrb,\ list,\ ary);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ arystr\ =\ mrb\_str\_new\_capa(mrb,\ 64);}
\DoxyCodeLine{\ \ \mbox{\hyperlink{string_8h_ab2a1509f1b8da7063eca22622688c0af}{mrb\_str\_cat}}(mrb,\ arystr,\ head,\ \textcolor{keyword}{sizeof}(head));}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{for}\ (i=0;\ i<RARRAY\_LEN(ary);\ i++)\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{int}\ ai\ =\ mrb\_gc\_arena\_save(mrb);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{if}\ (i\ >\ 0)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \mbox{\hyperlink{string_8h_ab2a1509f1b8da7063eca22622688c0af}{mrb\_str\_cat}}(mrb,\ arystr,\ sep,\ \textcolor{keyword}{sizeof}(sep));}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{if}\ (mrb\_array\_p(RARRAY\_PTR(ary)[i]))\ \{}
\DoxyCodeLine{\ \ \ \ \ \ s\ =\ inspect\_ary(mrb,\ RARRAY\_PTR(ary)[i],\ list);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{\ \ \ \ \ \ s\ =\ mrb\_inspect(mrb,\ RARRAY\_PTR(ary)[i]);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{string_8h_ab2a1509f1b8da7063eca22622688c0af}{mrb\_str\_cat}}(mrb,\ arystr,\ RSTRING\_PTR(s),\ RSTRING\_LEN(s));}
\DoxyCodeLine{\ \ \ \ mrb\_gc\_arena\_restore(mrb,\ ai);}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \mbox{\hyperlink{string_8h_ab2a1509f1b8da7063eca22622688c0af}{mrb\_str\_cat}}(mrb,\ arystr,\ tail,\ \textcolor{keyword}{sizeof}(tail));}
\DoxyCodeLine{\ \ mrb\_ary\_pop(mrb,\ list);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{return}\ arystr;}
\DoxyCodeLine{\}}

\end{DoxyCode}


This is a real example, so slightly complicated, but bear with me. The essence of {\ttfamily Array\#inspect} is that after stringifying each element of array using {\ttfamily inspect} method, we join them together so that we can get {\ttfamily inspect} representation of the entire array.

After the {\ttfamily inspect} representation is created, we no longer require the individual string representation. This means that we don\textquotesingle{}t have to register these temporal objects into GC arena.

Therefore, in order to keep the arena size small; the {\ttfamily ary\+\_\+inspect()} function will do the following\+:


\begin{DoxyItemize}
\item save the position of the stack top using {\ttfamily mrb\+\_\+gc\+\_\+arena\+\_\+save()}.
\item get {\ttfamily inspect} representation of each element.
\item append it to the constructing entire {\ttfamily inspect} representation of array.
\item restore stack top position using {\ttfamily mrb\+\_\+gc\+\_\+arena\+\_\+restore()}.
\end{DoxyItemize}

Please note that the final {\ttfamily inspect} representation of entire array was created before the call of {\ttfamily mrb\+\_\+gc\+\_\+arena\+\_\+restore()}. Otherwise, required temporal object may be deleted by GC.

We may have an usecase where after creating many temporal objects, we\textquotesingle{}d like to keep some of them. In this case, we cannot use the same idea in {\ttfamily ary\+\_\+inspect()} like appending objects to existing one. Instead, after {\ttfamily mrb\+\_\+gc\+\_\+arena\+\_\+restore()}, we must re-\/register the objects we want to keep in the arena using {\ttfamily mrb\+\_\+gc\+\_\+protect(mrb, obj)}. Use {\ttfamily mrb\+\_\+gc\+\_\+protect()} with caution because it could also lead to an "{}arena overflow error"{}.

We must also mention that when {\ttfamily \doxylink{mruby_8h_ab0c4a601cb4dc2ddf3470d604dbc9113}{mrb\+\_\+funcall}} is called in top level, the return value is also registered to GC arena, so repeated use of {\ttfamily \doxylink{mruby_8h_ab0c4a601cb4dc2ddf3470d604dbc9113}{mrb\+\_\+funcall}} may eventually lead to an "{}arena overflow error"{}.

Use {\ttfamily mrb\+\_\+gc\+\_\+arena\+\_\+save()} and {\ttfamily mrb\+\_\+gc\+\_\+arena\+\_\+restore()} or possible use of {\ttfamily mrb\+\_\+gc\+\_\+protect()} to workaround this. 