<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BlueBox: managed_components/espressif__nghttp/nghttp2/third-party/urlparse/http-parser Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">BlueBox<span id="projectnumber">&#160;0.9</span>
   </div>
   <div id="projectbrief">BlueBox Bluetooth sink</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>managed_components</b></li><li class="navelem"><a href="dir_9daa05842a3b93b9b84970416d2aacb6.html">espressif__nghttp</a></li><li class="navelem"><b>nghttp2</b></li><li class="navelem"><b>third-party</b></li><li class="navelem"><b>urlparse</b></li><li class="navelem"><a href="dir_62123356adbeb899e10384ccfa6ed403.html">http-parser</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="headertitle"><div class="title">http-parser Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Directory dependency graph for http-parser:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="dir_62123356adbeb899e10384ccfa6ed403_dep.svg" width="331" height="171"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-subdirs" class="groupheader"><a id="subdirs" name="subdirs"></a>
Directories</h2></td></tr>
<tr class="memitem:contrib" id="r_contrib"><td class="memItemLeft" align="right" valign="top"><span class="iconfolder"><div class="folder-icon"></div></span>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dir_3415fbaf7c430b64618ef26042dbf151.html">contrib</a></td></tr>
<tr class="memitem:fuzzers" id="r_fuzzers"><td class="memItemLeft" align="right" valign="top"><span class="iconfolder"><div class="folder-icon"></div></span>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dir_c3573fb491647f82495536bc66ab9e35.html">fuzzers</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-files" class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:http_5Fparser_2Eh" id="r_http_5Fparser_2Eh"><td class="memItemLeft" align="right" valign="top"><a href="http__parser_8h_source.html"><span class="icondoc"><div class="doc-icon"></div></span></a>&#160;</td><td class="memItemRight" valign="bottom"><b>http_parser.h</b></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>http-parser is <a href="https://github.com/nodejs/http-parser/issues/522"><b>not</b> actively maintained</a>. New projects and projects looking to migrate should consider <a href="https://github.com/nodejs/llhttp">llhttp</a>.</p>
<p><a href="https://travis-ci.org/nodejs/http-parser"><img src="https://api.travis-ci.org/nodejs/http-parser.svg?branch=master" alt="Build Status" style="pointer-events: none;" class="inline"/></a></p>
<p>This is a parser for HTTP messages written in C. It parses both requests and responses. The parser is designed to be used in performance HTTP applications. It does not make any syscalls nor allocations, it does not buffer data, it can be interrupted at anytime. Depending on your architecture, it only requires about 40 bytes of data per message stream (in a web server that is per connection).</p>
<p>Features:</p>
<ul>
<li>No dependencies</li>
<li>Handles persistent streams (keep-alive).</li>
<li>Decodes chunked encoding.</li>
<li>Upgrade support</li>
<li>Defends against buffer overflow attacks.</li>
</ul>
<p>The parser extracts the following information from HTTP messages:</p>
<ul>
<li>Header fields and values</li>
<li>Content-Length</li>
<li><a class="el" href="structRequest.html">Request</a> method</li>
<li>Response status code</li>
<li>Transfer-Encoding</li>
<li>HTTP version</li>
<li><a class="el" href="structRequest.html">Request</a> URL</li>
<li>Message body</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md575"></a>
Usage</h1>
<p>One <span class="tt"><a class="el" href="structhttp__parser.html">http_parser</a></span> object is used per TCP connection. Initialize the struct using <span class="tt">http_parser_init()</span> and set the callbacks. That might look something like this for a request parser: </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structhttp__parser__settings.html">http_parser_settings</a> settings;</div>
<div class="line">settings.on_url = my_url_callback;</div>
<div class="line">settings.on_header_field = my_header_field_callback;</div>
<div class="line"><span class="comment">/* ... */</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structhttp__parser.html">http_parser</a> *parser = malloc(<span class="keyword">sizeof</span>(<a class="code hl_struct" href="structhttp__parser.html">http_parser</a>));</div>
<div class="line">http_parser_init(parser, HTTP_REQUEST);</div>
<div class="line">parser-&gt;data = my_socket;</div>
<div class="ttc" id="astructhttp__parser__settings_html"><div class="ttname"><a href="structhttp__parser__settings.html">http_parser_settings</a></div><div class="ttdef"><b>Definition</b> http_parser.h:334</div></div>
<div class="ttc" id="astructhttp__parser_html"><div class="ttname"><a href="structhttp__parser.html">http_parser</a></div><div class="ttdef"><b>Definition</b> http_parser.h:297</div></div>
</div><!-- fragment --><p>When data is received on the socket execute the parser and check for errors.</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> len = 80*1024, nparsed;</div>
<div class="line"><span class="keywordtype">char</span> buf[len];</div>
<div class="line">ssize_t recved;</div>
<div class="line"> </div>
<div class="line">recved = recv(fd, buf, len, 0);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (recved &lt; 0) {</div>
<div class="line">  <span class="comment">/* Handle error. */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Start up / continue the parser.</span></div>
<div class="line"><span class="comment"> * Note we pass recved==0 to signal that EOF has been received.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">nparsed = http_parser_execute(parser, &amp;settings, buf, recved);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (parser-&gt;upgrade) {</div>
<div class="line">  <span class="comment">/* handle new protocol */</span></div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nparsed != recved) {</div>
<div class="line">  <span class="comment">/* Handle error. Usually just close the connection. */</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><span class="tt"><a class="el" href="structhttp__parser.html">http_parser</a></span> needs to know where the end of the stream is. For example, sometimes servers send responses without Content-Length and expect the client to consume input (for the body) until EOF. To tell <span class="tt"><a class="el" href="structhttp__parser.html">http_parser</a></span> about EOF, give <span class="tt">0</span> as the fourth parameter to <span class="tt">http_parser_execute()</span>. Callbacks and errors can still be encountered during an EOF, so one must still be prepared to receive them.</p>
<p>Scalar valued message information such as <span class="tt">status_code</span>, <span class="tt">method</span>, and the HTTP version are stored in the parser structure. This data is only temporally stored in <span class="tt"><a class="el" href="structhttp__parser.html">http_parser</a></span> and gets reset on each new message. If this information is needed later, copy it out of the structure during the <span class="tt">headers_complete</span> callback.</p>
<p>The parser decodes the transfer-encoding for both requests and responses transparently. That is, a chunked encoding is decoded before being sent to the on_body callback.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md576"></a>
The Special Problem of Upgrade</h1>
<p><span class="tt"><a class="el" href="structhttp__parser.html">http_parser</a></span> supports upgrading the connection to a different protocol. An increasingly common example of this is the WebSocket protocol which sends a request like </p><pre class="fragment">    GET /demo HTTP/1.1
    Upgrade: WebSocket
    Connection: Upgrade
    Host: example.com
    Origin: http://example.com
    WebSocket-Protocol: sample
</pre><p>followed by non-HTTP data.</p>
<p>(See <a href="https://tools.ietf.org/html/rfc6455">RFC6455</a> for more information the WebSocket protocol.)</p>
<p>To support this, the parser will treat this as a normal HTTP message without a body, issuing both on_headers_complete and on_message_complete callbacks. However http_parser_execute() will stop parsing at the end of the headers and return.</p>
<p>The user is expected to check if <span class="tt">parser-&gt;upgrade</span> has been set to 1 after <span class="tt">http_parser_execute()</span> returns. Non-HTTP data begins at the buffer supplied offset by the return value of <span class="tt">http_parser_execute()</span>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md577"></a>
Callbacks</h1>
<p>During the <span class="tt">http_parser_execute()</span> call, the callbacks set in <span class="tt"><a class="el" href="structhttp__parser__settings.html">http_parser_settings</a></span> will be executed. The parser maintains state and never looks behind, so buffering the data is not necessary. If you need to save certain data for later usage, you can do that from the callbacks.</p>
<p>There are two types of callbacks:</p>
<ul>
<li>notification <span class="tt">typedef int (*http_cb) (http_parser*);</span> Callbacks: on_message_begin, on_headers_complete, on_message_complete.</li>
<li>data <span class="tt">typedef int (*http_data_cb) (http_parser*, const char *at, size_t length);</span> Callbacks: (requests only) on_url, (common) on_header_field, on_header_value, on_body;</li>
</ul>
<p>Callbacks must return 0 on success. Returning a non-zero value indicates error to the parser, making it exit immediately.</p>
<p>For cases where it is necessary to pass local information to/from a callback, the <span class="tt"><a class="el" href="structhttp__parser.html">http_parser</a></span> object's <span class="tt">data</span> field can be used. An example of such a case is when using threads to handle a socket connection, parse a request, and then give a response over that socket. By instantiation of a thread-local struct containing relevant data (e.g. accepted socket, allocated memory for callbacks to write into, etc), a parser's callbacks are able to communicate data between the scope of the thread and the scope of the callback in a threadsafe manner. This allows <span class="tt"><a class="el" href="structhttp__parser.html">http_parser</a></span> to be used in multi-threaded contexts.</p>
<p>Example: </p><div class="fragment"><div class="line"> <span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">  socket_t sock;</div>
<div class="line">  <span class="keywordtype">void</span>* buffer;</div>
<div class="line">  <span class="keywordtype">int</span> buf_len;</div>
<div class="line"> } custom_data_t;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> my_url_callback(<a class="code hl_struct" href="structhttp__parser.html">http_parser</a>* parser, <span class="keyword">const</span> <span class="keywordtype">char</span> *at, <span class="keywordtype">size_t</span> length) {</div>
<div class="line">  <span class="comment">/* access to thread local custom_data_t struct.</span></div>
<div class="line"><span class="comment">  Use this access save parsed data for later use into thread local</span></div>
<div class="line"><span class="comment">  buffer, or communicate over socket</span></div>
<div class="line"><span class="comment">  */</span></div>
<div class="line">  parser-&gt;data;</div>
<div class="line">  ...</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">void http_parser_thread(socket_t sock) {</div>
<div class="line"> <span class="keywordtype">int</span> nparsed = 0;</div>
<div class="line"> <span class="comment">/* allocate memory for user data */</span></div>
<div class="line"> custom_data_t *my_data = malloc(<span class="keyword">sizeof</span>(custom_data_t));</div>
<div class="line"> </div>
<div class="line"> <span class="comment">/* some information for use by callbacks.</span></div>
<div class="line"><span class="comment"> * achieves thread -&gt; callback information flow */</span></div>
<div class="line"> my_data-&gt;sock = sock;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">/* instantiate a thread-local parser */</span></div>
<div class="line"> <a class="code hl_struct" href="structhttp__parser.html">http_parser</a> *parser = malloc(<span class="keyword">sizeof</span>(<a class="code hl_struct" href="structhttp__parser.html">http_parser</a>));</div>
<div class="line"> http_parser_init(parser, HTTP_REQUEST); <span class="comment">/* initialise parser */</span></div>
<div class="line"> <span class="comment">/* this custom data reference is accessible through the reference to the</span></div>
<div class="line"><span class="comment"> parser supplied to callback functions */</span></div>
<div class="line"> parser-&gt;data = my_data;</div>
<div class="line"> </div>
<div class="line"> <a class="code hl_struct" href="structhttp__parser__settings.html">http_parser_settings</a> settings; <span class="comment">/* set up callbacks */</span></div>
<div class="line"> settings.on_url = my_url_callback;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">/* execute parser */</span></div>
<div class="line"> nparsed = http_parser_execute(parser, &amp;settings, buf, recved);</div>
<div class="line"> </div>
<div class="line"> ...</div>
<div class="line"> <span class="comment">/* parsed information copied from callback.</span></div>
<div class="line"><span class="comment"> can now perform action on data copied into thread-local memory from callbacks.</span></div>
<div class="line"><span class="comment"> achieves callback -&gt; thread information flow */</span></div>
<div class="line"> my_data-&gt;buffer;</div>
<div class="line"> ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>In case you parse HTTP message in chunks (i.e. <span class="tt">read()</span> request line from socket, parse, read half headers, parse, etc) your data callbacks may be called more than once. <span class="tt"><a class="el" href="structhttp__parser.html">http_parser</a></span> guarantees that data pointer is only valid for the lifetime of callback. You can also <span class="tt">read()</span> into a heap allocated buffer to avoid copying memory around if this fits your application.</p>
<p>Reading headers may be a tricky task if you read/parse headers partially. Basically, you need to remember whether last header callback was field or value and apply the following logic: </p><pre class="fragment">(on_header_field and on_header_value shortened to on_h_*)
 ------------------------ ------------ --------------------------------------------
| State (prev. callback) | Callback   | Description/action                         |
 ------------------------ ------------ --------------------------------------------
| nothing (first call)   | on_h_field | Allocate new buffer and copy callback data |
|                        |            | into it                                    |
 ------------------------ ------------ --------------------------------------------
| value                  | on_h_field | New header started.                        |
|                        |            | Copy current name,value buffers to headers |
|                        |            | list and allocate new buffer for new name  |
 ------------------------ ------------ --------------------------------------------
| field                  | on_h_field | Previous name continues. Reallocate name   |
|                        |            | buffer and append callback data to it      |
 ------------------------ ------------ --------------------------------------------
| field                  | on_h_value | Value for current header started. Allocate |
|                        |            | new buffer and copy callback data to it    |
 ------------------------ ------------ --------------------------------------------
| value                  | on_h_value | Value continues. Reallocate value buffer   |
|                        |            | and append callback data to it             |
 ------------------------ ------------ --------------------------------------------
</pre><h1 class="doxsection"><a class="anchor" id="autotoc_md578"></a>
Parsing URLs</h1>
<p>A simplistic zero-copy URL parser is provided as <span class="tt">http_parser_parse_url()</span>. Users of this library may wish to use it to parse URLs constructed from consecutive <span class="tt">on_url</span> callbacks.</p>
<p>See examples of reading in headers:</p>
<ul>
<li><a href="http://gist.github.com/155877">partial example</a> in C</li>
<li><a href="http://github.com/joyent/http-parser/blob/37a0ff8/test.c#L403">from http-parser tests</a> in C</li>
<li><a href="http://github.com/joyent/node/blob/842eaf4/src/http.js#L284">from Node library</a> in Javascript </li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
