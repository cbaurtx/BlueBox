<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BlueBox: managed_components/espressif__nghttp/nghttp2/third-party/llhttp Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">BlueBox<span id="projectnumber">&#160;0.9</span>
   </div>
   <div id="projectbrief">BlueBox Bluetooth sink</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>managed_components</b></li><li class="navelem"><a href="dir_9daa05842a3b93b9b84970416d2aacb6.html">espressif__nghttp</a></li><li class="navelem"><b>nghttp2</b></li><li class="navelem"><b>third-party</b></li><li class="navelem"><a href="dir_a751cff038502cf36796791fd6ea90fe.html">llhttp</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="headertitle"><div class="title">llhttp Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Directory dependency graph for llhttp:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="dir_a751cff038502cf36796791fd6ea90fe_dep.svg" width="275" height="192"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-subdirs" class="groupheader"><a id="subdirs" name="subdirs"></a>
Directories</h2></td></tr>
<tr class="memitem:include" id="r_include"><td class="memItemLeft" align="right" valign="top"><span class="iconfolder"><div class="folder-icon"></div></span>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dir_78f3f26d6f17fb4cc900d1a270a89728.html">include</a></td></tr>
<tr class="memitem:src" id="r_src"><td class="memItemLeft" align="right" valign="top"><span class="iconfolder"><div class="folder-icon"></div></span>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dir_3112e4d21d0b179942cb9ef5bc54b629.html">src</a></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<h1 class="doxsection"><a class="anchor" id="autotoc_md213"></a>
llhttp</h1>
<p><a href="https://github.com/nodejs/llhttp/actions?query=workflow%3ACI"><img src="https://github.com/nodejs/llhttp/workflows/CI/badge.svg" alt="CI" style="pointer-events: none;" class="inline"/></a></p>
<p>Port of <a href="https://github.com/nodejs/http-parser">http_parser</a> to <a href="https://github.com/nodejs/llparse">llparse</a>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md214"></a>
Why?</h1>
<p>Let's face it, <a href="https://github.com/nodejs/http-parser">http_parser</a> is practically unmaintainable. Even introduction of a single new method results in a significant code churn.</p>
<p>This project aims to:</p>
<ul>
<li>Make it maintainable</li>
<li>Verifiable</li>
<li>Improving benchmarks where possible</li>
</ul>
<p>More details in <a href="https://youtu.be/x3k_5Mi66sY">Fedor Indutny's talk at JSConf EU 2019</a></p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md215"></a>
How?</h1>
<p>Over time, different approaches for improving <a href="https://github.com/nodejs/http-parser">http_parser</a>'s code base were tried. However, all of them failed due to resulting significant performance degradation.</p>
<p>This project is a port of <a href="https://github.com/nodejs/http-parser">http_parser</a> to TypeScript. <a href="https://github.com/nodejs/llparse">llparse</a> is used to generate the output C source file, which could be compiled and linked with the embedder's program (like <a href="https://github.com/nodejs/node">Node.js</a>).</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md216"></a>
Performance</h1>
<p>So far llhttp outperforms <a class="el" href="structhttp__parser.html">http_parser</a>:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft"></th><th class="markdownTableHeadRight">input size  </th><th class="markdownTableHeadRight">bandwidth  </th><th class="markdownTableHeadRight">reqs/sec  </th><th class="markdownTableHeadRight">time  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>llhttp</b>  </td><td class="markdownTableBodyRight">8192.00 mb  </td><td class="markdownTableBodyRight">1777.24 mb/s  </td><td class="markdownTableBodyRight">3583799.39 req/sec  </td><td class="markdownTableBodyRight">4.61 s  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b><a class="el" href="structhttp__parser.html">http_parser</a></b>  </td><td class="markdownTableBodyRight">8192.00 mb  </td><td class="markdownTableBodyRight">694.66 mb/s  </td><td class="markdownTableBodyRight">1406180.33 req/sec  </td><td class="markdownTableBodyRight">11.79 s  </td></tr>
</table>
<p>llhttp is faster by approximately <b>156%</b>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md217"></a>
Maintenance</h1>
<p>llhttp project has about 1400 lines of TypeScript code describing the parser itself and around 450 lines of C code and headers providing the helper methods. The whole <a href="https://github.com/nodejs/http-parser">http_parser</a> is implemented in approximately 2500 lines of C, and 436 lines of headers.</p>
<p>All optimizations and multi-character matching in llhttp are generated automatically, and thus doesn't add any extra maintenance cost. On the contrary, most of <a class="el" href="structhttp__parser.html">http_parser</a>'s code is hand-optimized and unrolled. Instead describing "how" it should parse the HTTP requests/responses, a maintainer should implement the new features in <a href="https://github.com/nodejs/http-parser">http_parser</a> cautiously, considering possible performance degradation and manually optimizing the new code.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md218"></a>
Verification</h1>
<p>The state machine graph is encoded explicitly in llhttp. The <a href="https://github.com/nodejs/llparse">llparse</a> automatically checks the graph for absence of loops and correct reporting of the input ranges (spans) like header names and values. In the future, additional checks could be performed to get even stricter verification of the llhttp.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md219"></a>
Usage</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;stdio.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;llhttp.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="string_8h.html">string.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> handle_on_message_complete(llhttp_t* parser) {</div>
<div class="line">    fprintf(stdout, <span class="stringliteral">&quot;Message completed!\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    llhttp_t parser;</div>
<div class="line">    llhttp_settings_t settings;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/*Initialize user callbacks and settings */</span></div>
<div class="line">    llhttp_settings_init(&amp;settings);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/*Set user callback */</span></div>
<div class="line">    settings.on_message_complete = handle_on_message_complete;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/*Initialize the parser in HTTP_BOTH mode, meaning that it will select between</span></div>
<div class="line"><span class="comment">    *HTTP_REQUEST and HTTP_RESPONSE parsing automatically while reading the first</span></div>
<div class="line"><span class="comment">    *input.</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">    llhttp_init(&amp;parser, HTTP_BOTH, &amp;settings);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/*Parse request! */</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* request = <span class="stringliteral">&quot;GET / HTTP/1.1\r\n\r\n&quot;</span>;</div>
<div class="line">    <span class="keywordtype">int</span> request_len = strlen(request);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">enum</span> llhttp_errno err = llhttp_execute(&amp;parser, request, request_len);</div>
<div class="line">    <span class="keywordflow">if</span> (err == HPE_OK) {</div>
<div class="line">        fprintf(stdout, <span class="stringliteral">&quot;Successfully parsed!\n&quot;</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Parse error: %s %s\n&quot;</span>, llhttp_errno_name(err), parser.reason);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="astring_8h_html"><div class="ttname"><a href="string_8h.html">string.h</a></div></div>
</div><!-- fragment --><p> For more information on API usage, please refer to <a href="https://github.com/nodejs/llhttp/blob/main/src/native/api.h">src/native/api.h</a>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md220"></a>
API</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md221"></a>
llhttp_settings_t</h2>
<p>The settings object contains a list of callbacks that the parser will invoke.</p>
<p>The following callbacks can return <span class="tt">0</span> (proceed normally), <span class="tt">-1</span> (error) or <span class="tt">HPE_PAUSED</span> (pause the parser):</p>
<ul>
<li><span class="tt">on_message_begin</span>: Invoked when a new request/response starts.</li>
<li><span class="tt">on_message_complete</span>: Invoked when a request/response has been completedly parsed.</li>
<li><span class="tt">on_url_complete</span>: Invoked after the URL has been parsed.</li>
<li><span class="tt">on_method_complete</span>: Invoked after the HTTP method has been parsed.</li>
<li><span class="tt">on_version_complete</span>: Invoked after the HTTP version has been parsed.</li>
<li><span class="tt">on_status_complete</span>: Invoked after the status code has been parsed.</li>
<li><span class="tt">on_header_field_complete</span>: Invoked after a header name has been parsed.</li>
<li><span class="tt">on_header_value_complete</span>: Invoked after a header value has been parsed.</li>
<li><span class="tt">on_chunk_header</span>: Invoked after a new chunk is started. The current chunk length is stored in <span class="tt">parser-&gt;content_length</span>.</li>
<li><span class="tt">on_chunk_extension_name_complete</span>: Invoked after a chunk extension name is started.</li>
<li><span class="tt">on_chunk_extension_value_complete</span>: Invoked after a chunk extension value is started.</li>
<li><span class="tt">on_chunk_complete</span>: Invoked after a new chunk is received.</li>
<li><span class="tt">on_reset</span>: Invoked after <span class="tt">on_message_complete</span> and before <span class="tt">on_message_begin</span> when a new message is received on the same parser. This is not invoked for the first message of the parser.</li>
</ul>
<p>The following callbacks can return <span class="tt">0</span> (proceed normally), <span class="tt">-1</span> (error) or <span class="tt">HPE_USER</span> (error from the callback):</p>
<ul>
<li><span class="tt">on_url</span>: Invoked when another character of the URL is received.</li>
<li><span class="tt">on_status</span>: Invoked when another character of the status is received.</li>
<li><span class="tt">on_method</span>: Invoked when another character of the method is received. When parser is created with <span class="tt">HTTP_BOTH</span> and the input is a response, this also invoked for the sequence <span class="tt">HTTP/</span> of the first message.</li>
<li><span class="tt">on_version</span>: Invoked when another character of the version is received.</li>
<li><span class="tt">on_header_field</span>: Invoked when another character of a header name is received.</li>
<li><span class="tt">on_header_value</span>: Invoked when another character of a header value is received.</li>
<li><span class="tt">on_chunk_extension_name</span>: Invoked when another character of a chunk extension name is received.</li>
<li><span class="tt">on_chunk_extension_value</span>: Invoked when another character of a extension value is received.</li>
</ul>
<p>The callback <span class="tt">on_headers_complete</span>, invoked when headers are completed, can return:</p>
<ul>
<li><span class="tt">0</span>: Proceed normally.</li>
<li><span class="tt">1</span>: Assume that request/response has no body, and proceed to parsing the next message.</li>
<li><span class="tt">2</span>: Assume absence of body (as above) and make <span class="tt">llhttp_execute()</span> return <span class="tt">HPE_PAUSED_UPGRADE</span>.</li>
<li><span class="tt">-1</span>: Error</li>
<li><span class="tt">HPE_PAUSED</span>: Pause the parser.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md222"></a>
<span class="tt">void llhttp_init(llhttp_t* parser, llhttp_type_t type, const llhttp_settings_t* settings)</span></h2>
<p>Initialize the parser with specific type and user settings.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md223"></a>
<span class="tt">uint8_t llhttp_get_type(llhttp_t* parser)</span></h2>
<p>Returns the type of the parser.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md224"></a>
<span class="tt">uint8_t llhttp_get_http_major(llhttp_t* parser)</span></h2>
<p>Returns the major version of the HTTP protocol of the current request/response.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md225"></a>
<span class="tt">uint8_t llhttp_get_http_minor(llhttp_t* parser)</span></h2>
<p>Returns the minor version of the HTTP protocol of the current request/response.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md226"></a>
<span class="tt">uint8_t llhttp_get_method(llhttp_t* parser)</span></h2>
<p>Returns the method of the current request.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md227"></a>
<span class="tt">int llhttp_get_status_code(llhttp_t* parser)</span></h2>
<p>Returns the method of the current response.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md228"></a>
<span class="tt">uint8_t llhttp_get_upgrade(llhttp_t* parser)</span></h2>
<p>Returns <span class="tt">1</span> if request includes the <span class="tt"><a class="el" href="structConnection.html">Connection</a>: upgrade</span> header.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md229"></a>
<span class="tt">void llhttp_reset(llhttp_t* parser)</span></h2>
<p>Reset an already initialized parser back to the start state, preserving the existing parser type, callback settings, user data, and lenient flags.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md230"></a>
<span class="tt">void llhttp_settings_init(llhttp_settings_t* settings)</span></h2>
<p>Initialize the settings object.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md231"></a>
<span class="tt">llhttp_errno_t llhttp_execute(llhttp_t* parser, const char* data, size_t len)</span></h2>
<p>Parse full or partial request/response, invoking user callbacks along the way.</p>
<p>If any of <span class="tt">llhttp_data_cb</span> returns errno not equal to <span class="tt">HPE_OK</span> - the parsing interrupts, and such errno is returned from <span class="tt">llhttp_execute()</span>. If <span class="tt">HPE_PAUSED</span> was used as a errno, the execution can be resumed with <span class="tt">llhttp_resume()</span> call.</p>
<p>In a special case of CONNECT/Upgrade request/response <span class="tt">HPE_PAUSED_UPGRADE</span> is returned after fully parsing the request/response. If the user wishes to continue parsing, they need to invoke <span class="tt">llhttp_resume_after_upgrade()</span>.</p>
<p><b>if this function ever returns a non-pause type error, it will continue to return the same error upon each successive call up until <span class="tt">llhttp_init()</span> is called.</b></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md232"></a>
<span class="tt">llhttp_errno_t llhttp_finish(llhttp_t* parser)</span></h2>
<p>This method should be called when the other side has no further bytes to send (e.g. shutdown of readable side of the TCP connection.)</p>
<p>Requests without <span class="tt">Content-Length</span> and other messages might require treating all incoming bytes as the part of the body, up to the last byte of the connection.</p>
<p>This method will invoke <span class="tt">on_message_complete()</span> callback if the request was terminated safely. Otherwise a error code would be returned.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md233"></a>
<span class="tt">int llhttp_message_needs_eof(const llhttp_t* parser)</span></h2>
<p>Returns <span class="tt">1</span> if the incoming message is parsed until the last byte, and has to be completed by calling <span class="tt">llhttp_finish()</span> on EOF.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md234"></a>
<span class="tt">int llhttp_should_keep_alive(const llhttp_t* parser)</span></h2>
<p>Returns <span class="tt">1</span> if there might be any other messages following the last that was successfully parsed.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md235"></a>
<span class="tt">void llhttp_pause(llhttp_t* parser)</span></h2>
<p>Make further calls of <span class="tt">llhttp_execute()</span> return <span class="tt">HPE_PAUSED</span> and set appropriate error reason.</p>
<p><b>Do not call this from user callbacks! User callbacks must return <span class="tt">HPE_PAUSED</span> if pausing is required.</b></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md236"></a>
<span class="tt">void llhttp_resume(llhttp_t* parser)</span></h2>
<p>Might be called to resume the execution after the pause in user's callback.</p>
<p>See <span class="tt">llhttp_execute()</span> above for details.</p>
<p><b>Call this only if <span class="tt">llhttp_execute()</span> returns <span class="tt">HPE_PAUSED</span>.</b></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md237"></a>
<span class="tt">void llhttp_resume_after_upgrade(llhttp_t* parser)</span></h2>
<p>Might be called to resume the execution after the pause in user's callback. See <span class="tt">llhttp_execute()</span> above for details.</p>
<p><b>Call this only if <span class="tt">llhttp_execute()</span> returns <span class="tt">HPE_PAUSED_UPGRADE</span></b></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md238"></a>
<span class="tt">llhttp_errno_t llhttp_get_errno(const llhttp_t* parser)</span></h2>
<p>Returns the latest error.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md239"></a>
<span class="tt">const char* llhttp_get_error_reason(const llhttp_t* parser)</span></h2>
<p>Returns the verbal explanation of the latest returned error.</p>
<p><b>User callback should set error reason when returning the error. See <span class="tt">llhttp_set_error_reason()</span> for details.</b></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md240"></a>
<span class="tt">void llhttp_set_error_reason(llhttp_t* parser, const char* reason)</span></h2>
<p>Assign verbal description to the returned error. Must be called in user callbacks right before returning the errno.</p>
<p><b><span class="tt">HPE_USER</span> error code might be useful in user callbacks.</b></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md241"></a>
<span class="tt">const char* llhttp_get_error_pos(const llhttp_t* parser)</span></h2>
<p>Returns the pointer to the last parsed byte before the returned error. The pointer is relative to the <span class="tt">data</span> argument of <span class="tt">llhttp_execute()</span>.</p>
<p><b>This method might be useful for counting the number of parsed bytes.</b></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md242"></a>
<span class="tt">const char* llhttp_errno_name(llhttp_errno_t err)</span></h2>
<p>Returns textual name of error code.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md243"></a>
<span class="tt">const char* llhttp_method_name(llhttp_method_t method)</span></h2>
<p>Returns textual name of HTTP method.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md244"></a>
<span class="tt">const char* llhttp_status_name(llhttp_status_t status)</span></h2>
<p>Returns textual name of HTTP status.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md245"></a>
<span class="tt">void llhttp_set_lenient_headers(llhttp_t* parser, int enabled)</span></h2>
<p>Enables/disables lenient header value parsing (disabled by default). Lenient parsing disables header value token checks, extending llhttp's protocol support to highly non-compliant clients/server.</p>
<p>No <span class="tt">HPE_INVALID_HEADER_TOKEN</span> will be raised for incorrect header values when lenient parsing is "on".</p>
<p><b>Enabling this flag can pose a security issue since you will be exposed to request smuggling attacks. USE WITH CAUTION!</b></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md246"></a>
<span class="tt">void llhttp_set_lenient_chunked_length(llhttp_t* parser, int enabled)</span></h2>
<p>Enables/disables lenient handling of conflicting <span class="tt">Transfer-Encoding</span> and <span class="tt">Content-Length</span> headers (disabled by default).</p>
<p>Normally <span class="tt">llhttp</span> would error when <span class="tt">Transfer-Encoding</span> is present in conjunction with <span class="tt">Content-Length</span>.</p>
<p>This error is important to prevent HTTP request smuggling, but may be less desirable for small number of cases involving legacy servers.</p>
<p><b>Enabling this flag can pose a security issue since you will be exposed to request smuggling attacks. USE WITH CAUTION!</b></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md247"></a>
<span class="tt">void llhttp_set_lenient_keep_alive(llhttp_t* parser, int enabled)</span></h2>
<p>Enables/disables lenient handling of <span class="tt"><a class="el" href="structConnection.html">Connection</a>: close</span> and HTTP/1.0 requests responses.</p>
<p>Normally <span class="tt">llhttp</span> would error the HTTP request/response after the request/response with <span class="tt"><a class="el" href="structConnection.html">Connection</a>: close</span> and <span class="tt">Content-Length</span>.</p>
<p>This is important to prevent cache poisoning attacks, but might interact badly with outdated and insecure clients.</p>
<p>With this flag the extra request/response will be parsed normally.</p>
<p><b>Enabling this flag can pose a security issue since you will be exposed to poisoning attacks. USE WITH CAUTION!</b></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md248"></a>
<span class="tt">void llhttp_set_lenient_transfer_encoding(llhttp_t* parser, int enabled)</span></h2>
<p>Enables/disables lenient handling of <span class="tt">Transfer-Encoding</span> header.</p>
<p>Normally <span class="tt">llhttp</span> would error when a <span class="tt">Transfer-Encoding</span> has <span class="tt">chunked</span> value and another value after it (either in a single header or in multiple headers whose value are internally joined using <span class="tt">, </span>).</p>
<p>This is mandated by the spec to reliably determine request body size and thus avoid request smuggling.</p>
<p>With this flag the extra value will be parsed normally.</p>
<p><b>Enabling this flag can pose a security issue since you will be exposed to request smuggling attacks. USE WITH CAUTION!</b></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md249"></a>
<span class="tt">void llhttp_set_lenient_version(llhttp_t* parser, int enabled)</span></h2>
<p>Enables/disables lenient handling of HTTP version.</p>
<p>Normally <span class="tt">llhttp</span> would error when the HTTP version in the request or status line is not <span class="tt">0.9</span>, <span class="tt">1.0</span>, <span class="tt">1.1</span> or <span class="tt">2.0</span>. With this flag the extra value will be parsed normally.</p>
<p><b>Enabling this flag can pose a security issue since you will allow unsupported HTTP versions. USE WITH CAUTION!</b></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md250"></a>
<span class="tt">void llhttp_set_lenient_data_after_close(llhttp_t* parser, int enabled)</span></h2>
<p>Enables/disables lenient handling of additional data received after a message ends and keep-alive is disabled.</p>
<p>Normally <span class="tt">llhttp</span> would error when additional unexpected data is received if the message contains the <span class="tt"><a class="el" href="structConnection.html">Connection</a></span> header with <span class="tt">close</span> value. With this flag the extra data will discarded without throwing an error.</p>
<p><b>Enabling this flag can pose a security issue since you will be exposed to poisoning attacks. USE WITH CAUTION!</b></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md251"></a>
<span class="tt">void llhttp_set_lenient_optional_lf_after_cr(llhttp_t* parser, int enabled)</span></h2>
<p>Enables/disables lenient handling of incomplete CRLF sequences.</p>
<p>Normally <span class="tt">llhttp</span> would error when a CR is not followed by LF when terminating the request line, the status line, the headers or a chunk header. With this flag only a CR is required to terminate such sections.</p>
<p><b>Enabling this flag can pose a security issue since you will be exposed to request smuggling attacks. USE WITH CAUTION!</b></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md252"></a>
<span class="tt">void llhttp_set_lenient_optional_cr_before_lf(llhttp_t* parser, int enabled)</span></h2>
<p>Enables/disables lenient handling of line separators.</p>
<p>Normally <span class="tt">llhttp</span> would error when a LF is not preceded by CR when terminating the request line, the status line, the headers, a chunk header or a chunk data. With this flag only a LF is required to terminate such sections.</p>
<p><b>Enabling this flag can pose a security issue since you will be exposed to request smuggling attacks. USE WITH CAUTION!</b></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md253"></a>
<span class="tt">void llhttp_set_lenient_optional_crlf_after_chunk(llhttp_t* parser, int enabled)</span></h2>
<p>Enables/disables lenient handling of chunks not separated via CRLF.</p>
<p>Normally <span class="tt">llhttp</span> would error when after a chunk data a CRLF is missing before starting a new chunk. With this flag the new chunk can start immediately after the previous one.</p>
<p><b>Enabling this flag can pose a security issue since you will be exposed to request smuggling attacks. USE WITH CAUTION!</b></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md254"></a>
<span class="tt">void llhttp_set_lenient_spaces_after_chunk_size(llhttp_t* parser, int enabled)</span></h2>
<p>Enables/disables lenient handling of spaces after chunk size.</p>
<p>Normally <span class="tt">llhttp</span> would error when after a chunk size is followed by one or more spaces are present instead of a CRLF or <span class="tt">;</span>. With this flag this check is disabled.</p>
<p><b>Enabling this flag can pose a security issue since you will be exposed to request smuggling attacks. USE WITH CAUTION!</b></p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md255"></a>
Build Instructions</h1>
<p>Make sure you have <a href="https://nodejs.org/">Node.js</a>, npm and npx installed. Then under project directory run:</p>
<div class="fragment"><div class="line">npm ci</div>
<div class="line">make</div>
</div><!-- fragment --><hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md257"></a>
Bindings to other languages</h2>
<ul>
<li>Lua: <a href="https://github.com/MunifTanjim/llhttp.lua">MunifTanjim/llhttp.lua</a></li>
<li>Python: <a href="https://github.com/pallas/pyllhttp">pallas/pyllhttp</a></li>
<li>Ruby: <a href="https://github.com/metabahn/llhttp">metabahn/llhttp</a></li>
<li>Rust: <a href="https://github.com/JackLiar/rust-llhttp">JackLiar/rust-llhttp</a></li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md258"></a>
Using with CMake</h2>
<p>If you want to use this library in a CMake project as a shared library, you can use the snippet below.</p>
<div class="fragment"><div class="line">FetchContent_Declare(llhttp</div>
<div class="line">  URL &quot;https://github.com/nodejs/llhttp/archive/refs/tags/release/v8.1.0.tar.gz&quot;)</div>
<div class="line"> </div>
<div class="line">FetchContent_MakeAvailable(llhttp)</div>
<div class="line"> </div>
<div class="line"># Link with the llhttp_shared target</div>
<div class="line">target_link_libraries(${EXAMPLE_PROJECT_NAME} ${PROJECT_LIBRARIES} llhttp_shared ${PROJECT_NAME})</div>
</div><!-- fragment --><p>If you want to use this library in a CMake project as a static library, you can set some cache variables first.</p>
<div class="fragment"><div class="line">FetchContent_Declare(llhttp</div>
<div class="line">  URL &quot;https://github.com/nodejs/llhttp/archive/refs/tags/release/v8.1.0.tar.gz&quot;)</div>
<div class="line"> </div>
<div class="line">set(BUILD_SHARED_LIBS OFF CACHE INTERNAL &quot;&quot;)</div>
<div class="line">set(BUILD_STATIC_LIBS ON CACHE INTERNAL &quot;&quot;)</div>
<div class="line">FetchContent_MakeAvailable(llhttp)</div>
<div class="line"> </div>
<div class="line"># Link with the llhttp_static target</div>
<div class="line">target_link_libraries(${EXAMPLE_PROJECT_NAME} ${PROJECT_LIBRARIES} llhttp_static ${PROJECT_NAME})</div>
</div><!-- fragment --><p><em>Note that using the git repo directly (e.g., via a git repo url and tag) will not work with FetchContent_Declare because <a href="./CMakeLists.txt">CMakeLists.txt</a> requires string replacements (e.g., `_RELEASE</em>`) before it will build._</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md259"></a>
Building on Windows</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md260"></a>
Installation</h2>
<ul>
<li><span class="tt">choco install git</span></li>
<li><span class="tt">choco install <a class="el" href="structnode.html">node</a></span></li>
<li><span class="tt">choco install llvm</span> (or install the <span class="tt">C++ Clang tools for Windows</span> optional package from the Visual Studio 2019 installer)</li>
<li><span class="tt">choco install make</span> (or if you have MinGW, it comes bundled)</li>
</ul>
<ol type="1">
<li>Ensure that <span class="tt">Clang</span> and <span class="tt">make</span> are in your system path.</li>
<li>Using Git Bash, clone the repo to your preferred location.</li>
<li>Cd into the cloned directory and run <span class="tt">npm ci</span></li>
<li>Run <span class="tt">make</span></li>
<li>Your <span class="tt">repo/build</span> directory should now have <span class="tt">libllhttp.a</span> and <span class="tt">libllhttp.so</span> static and dynamic libraries.</li>
<li>When building your executable, you can link to these libraries. Make sure to set the build folder as an include path when building so you can reference the declarations in <span class="tt">repo/build/llhttp.h</span>.</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="autotoc_md261"></a>
A simple example on linking with the library:</h2>
<p>Assuming you have an executable <span class="tt">main.cpp</span> in your current working directory, you would run: <span class="tt">clang++ -Os -g3 -Wall -Wextra -Wno-unused-parameter -I/path/to/llhttp/build main.cpp /path/to/llhttp/build/libllhttp.a -o main.exe</span>.</p>
<p>If you are getting <span class="tt">unresolved external symbol</span> linker errors you are likely attempting to build <span class="tt">llhttp.c</span> without linking it with object files from <span class="tt">api.c</span> and <span class="tt">http.c</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md262"></a>
LICENSE</h3>
<p>This software is licensed under the MIT License.</p>
<p>Copyright Fedor Indutny, 2018.</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. </p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
